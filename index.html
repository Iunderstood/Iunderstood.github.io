<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="newlife means newborn">
<meta property="og:type" content="website">
<meta property="og:title" content="newlife&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="newlife&#39;s blog">
<meta property="og:description" content="newlife means newborn">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="newlife&#39;s blog">
<meta name="twitter:description" content="newlife means newborn">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>newlife's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">newlife's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/22/Node-js之JS高级/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/22/Node-js之JS高级/" itemprop="url">Node.js之JS高级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-22T15:29:42+08:00">
                2017-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h1><p><img src="/img/js高级/对象是属性的集合.png" alt="对象是属性的集合" title="对象是属性的集合.png"></p>
<h1 id="函数和对象的关系"><a href="#函数和对象的关系" class="headerlink" title="函数和对象的关系"></a>函数和对象的关系</h1><ul>
<li>对象都是通过函数创建的</li>
<li>函数是对象的一种</li>
</ul>
<p><img src="/img/js高级/函数和对象的关系.png" alt="函数和对象的关系" title="函数和对象的关系.png"></p>
<h4 id="判断变量类型几种方法"><a href="#判断变量类型几种方法" class="headerlink" title="判断变量类型几种方法"></a>判断变量类型几种方法</h4><ol>
<li>typeof 基本类型和function</li>
<li>instanceof 原型链来判断 判断不同的对象类型</li>
<li>Object.prototype.toString.call(fn); //[object Function] 判断不同的对象类型</li>
<li>通过这个变量的一些特征来判断</li>
<li>通过constructor来判断(constructor可以被 修改，所以有可能不准确)</li>
</ol>
<h4 id="JS提供给我们的语法糖-其实下面的字面量定义方式其实都是通过-new-关键字来实现的"><a href="#JS提供给我们的语法糖-其实下面的字面量定义方式其实都是通过-new-关键字来实现的" class="headerlink" title="JS提供给我们的语法糖(其实下面的字面量定义方式其实都是通过 new 关键字来实现的)"></a>JS提供给我们的语法糖(其实下面的字面量定义方式其实都是通过 new 关键字来实现的)</h4><blockquote>
<p>语法糖:它意指那些没有给计算机语言添加新功能，而只是对人类来说更“甜蜜”的语法。语法糖往往给程序员提供了更实用的编码方式，有益于更好的编码风格，更易读。不过其并没有给语言添加什么新东西。</p>
</blockquote>
<pre><code>var obj = new Object();
var arr = new Array();
var obj2 = {};
var arr2 = [,,];
function fn(a,b){
    console.log(a+b);
}
/**
 * 1.函数名 fn
 * 2. 函数参数
 * 3. 函数体 最后一个参数
 */
var fn2 = new Function(&apos;a&apos;,&apos;b&apos;,&apos;console.log(a+b)&apos;);
fn(1,3);
</code></pre><h1 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h1><p><img src="/img/js高级/prototype.png" alt="prototype" title="prototype.png"></p>
<p><img src="/img/js高级/instanceof.png" alt="instanceof" title="instanceof.png"></p>
<h4 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h4><p><img src="/img/js高级/proto1.png" alt="__proto__1" title="__proto__1.png"></p>
<p><img src="/img/js高级/proto2.png" alt="__proto__2" title="__proto__2.png"></p>
<p><img src="/img/js高级/proto3.png" alt="__proto__3" title="__proto__3.png"></p>
<p><img src="/img/js高级/proto4.png" alt="__proto__4" title="__proto__4.png"></p>
<p>代码示例：</p>
<pre><code>//通过调用new Function来创建一个函数的对象
var Foo = new Function(&apos;a&apos;,&apos;b&apos;,&apos;return a+b;&apos;);
//2.当创建add函数的时候，会自动送一个Add.prototype对象
var o1 = new Object();
//3.创建的对象的__proto__等于构造函数的prototype
console.log(o1.__proto__ === Object.prototype);

/**
 * 1. prototype叫原理 构造函数的属性
 * 2. __proto__叫隐式原型 通过构造函数构造出来的对象的属性
 **/
var f1 = new Foo();
console.log(f1 instanceof Foo);
// 左侧是对象实例 ，右侧是构造 函数
console.log(f1 instanceof Object);
</code></pre><h1 id="继承和原型链"><a href="#继承和原型链" class="headerlink" title="继承和原型链"></a>继承和原型链</h1><p><img src="/img/js高级/继承和原型链.png" alt="继承和原型链" title="继承和原型链.png"></p>
<p><img src="/img/js高级/原型链完整图例.png" alt="原型链完整图例" title="原型链完整图例.png"></p>
<p>代码示例：</p>
<pre><code>var Person = function(){
    //仅有的放在里面
    this.name = &apos;zfpx&apos;;
    this.age = 100;
}
//公用的放在外面
Person.prototype.getName = function(){
    console.log(this.name);
}

var p = new Person();
//找属性的时候是沿着__proto__这条线来找的
p.getName();
console.log(p.hasOwnProperty(&apos;name&apos;));//true
console.log(p.hasOwnProperty(&apos;getName&apos;));//false
</code></pre><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p><img src="/img/js高级/执行上下文.png" alt="执行上下文" title="执行上下文.png"></p>
<p><img src="/img/js高级/上下文中的变量对象.png" alt="上下文中的变量对象" title="上下文中的变量对象.png"></p>
<p>代码示例：</p>
<pre><code>/**
 * 全局代码执行时会产生一个执行上下文环境对象
 */
/*{
    this:&quot;上下文对象&quot;,
    a: var变量 预解释，但不赋值
    hello:函数表达式
    say:函数声明 预解释，并且赋值
    全局函数：
    alert
    Math
}*/
var a = 10;
say();
// 函数声明会预解释，会提取到最前面执行
function say(){}
//函数表达式，var会提前声明，但是不会赋值
var hello = function(){}
console.log(this.a);
console.log(a);
say();
// 自执行函数中的this永远是window
(function(){

})()
</code></pre><h1 id="函数的上下文环境"><a href="#函数的上下文环境" class="headerlink" title="函数的上下文环境"></a>函数的上下文环境</h1><p><img src="/img/js高级/函数内的预解释额外的变量.png" alt="函数内的预解释额外的变量" title="函数内的预解释额外的变量.png"></p>
<p>代码示例：</p>
<pre><code>var c =1;
/**
 * arguments 形参类数组  length callee caller 类数组
 * caller返回一个函数的引用，这个函数调用了当前的函数;callee返回正在执行的函数本身的引用，
 * 它是arguments的一个属性，这在函数的名称是未知时很有用，例如在没有名称的函数表达式 (也称为“匿名函数”)内
 */

function fn1(){
    var a =10;
    function fn2(){
        var b =5;
 // VO = var 函数声明 arguments
//先从当前的上下文环境中的VO中找，
//如果当前VO里没有，会从作用域链中找
        console.log(b);
        console.log(a);
        console.log(c);
    }
   fn2();
}
fn1();
</code></pre><blockquote>
<p>取值问题：</p>
</blockquote>
<pre><code>var a = 10;
function fn(){
    // fn 定义时它的父作用域是全局作用域
    console.log(a);//a的取值是在定义时确定的，而非运行时确定
}

function bar(f){
    var a = 20;
    // fn 运行时它的父作用域是 bar
    f();
}
bar(fn); // 这里的 a 取值为10
</code></pre><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p><img src="/img/js高级/this.png" alt="this" title="this.png"></p>
<p>代码示例：</p>
<pre><code>/**
 * 1. 当函数没有返回值的时候，new的时候返回this
 * 2.当函数有返回值的时候
 */
function Person(){
    this.name = &apos;zfpx&apos;;
    //console.log(this);
    //当return的是一个非对象类型的话，那么也返回this
    //如果返回的是一个对象类型的话
    //return {age:10};
}
var p = new Person();
console.log(p)

Person.prototype.getName = function(){
    console.log(this.name);
}
p.getName(); 
</code></pre><blockquote>
<p>this 的取值问题:</p>
</blockquote>
<ol>
<li>函数执行，首先看函数名前是否有“.”，有的话，“.”前面是谁this就是谁，没有的话，this就是window(非严格模式下)</li>
<li>自执行函数中的this永远是window</li>
<li>给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素</li>
</ol>
<blockquote>
<p>改变 this 的指向：call apply bind</p>
</blockquote>
<p>代码示例：</p>
<pre><code>function say(city,word){
    console.log(this.name,city,word);
}
say(&apos;乐乐&apos;,&apos;你好&apos;);
var person = {name:&apos;zfpx&apos;};
// apply第一个参数指定了函数运行时的this对象
say.apply(person,[&apos;乐乐&apos;,&apos;你好&apos;]);
say.call(person,&apos;乐乐&apos;,&apos;你好&apos;);

var newSay = say.bind(person,&apos;city&apos;);
newSay(&apos;word&apos;);
</code></pre><h1 id="作用域-scope"><a href="#作用域-scope" class="headerlink" title="作用域 scope"></a>作用域 scope</h1><p><img src="/img/js高级/作用域.png" alt="作用域" title="作用域.png"></p>
<p><img src="/img/js高级/作用域和执行上下文.png" alt="作用域和执行上下文" title="作用域和执行上下文.png"></p>
<p>代码示例：</p>
<pre><code>function one(){
    var a = Math.random();
    return function(){
        return a;
    }
}
var s = one();
var s2 = one(); // a 被 s,s2 占用，当前作用域不能被销毁，除非 s,s2 不再占用 a,那么该作用域会被浏览器销毁
console.log(s(),s2());
///没有块级作用域，es6可通过 let 声明块级作用域变量
var a = 100;
if(true){
    // &apos;use strict&apos; // 严格模式下依然没有块级作用域
    var a = 200;
}
console.log(a); // 200


for(var i=0;i&lt;10;i++){

}
console.log(i); // i 依然能被访问到
</code></pre><blockquote>
<p>百度百科：闭包就是能够读取其他函数内部变量的函数。由于在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁</p>
</blockquote>
<h1 id="once-方法的源代码实现"><a href="#once-方法的源代码实现" class="headerlink" title="once 方法的源代码实现"></a>once 方法的源代码实现</h1><p>代码：</p>
<pre><code>var EventEmiiter = require(&apos;events&apos;);
var e = new EventEmiiter();
e.once()
EventEmitter.prototype.once = function once(type, listener) {;
    //是否已经触发过
var fired = false;
    //声明了一个新的函数
    function g() {
        //移除监听
        this.removeListener(type, g);
        //如果没有触发过的话
        if (!fired) {
            fired = true;//状态改为已触发
            //调用一下原始的监听函数
            listener.apply(this, arguments);
        }
    }

    //其实绑定的是此函数内部声明的一个函数
    this.on(type, g);
};

// 精简代码：
EventEmitter.prototype.once = function once(type, listener) {;
    function g() {
        this.removeListener(type, g);
        listener.apply(this, arguments);
    }
    this.on(type, g);
};
</code></pre><h1 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h1><p>代码示例：</p>
<pre><code>function City(){}
function one(){
    var a = new City;
    return function(){
        return a;
    }
}
var s = one();
var s2 = one();
// 在浏览器中执行测试代码时，可以查看当前内存中的数据情况；方式： F12-&gt;Profiles-&gt;选择 Take Heap Snapshot-&gt;点击 Take Snapshot 按钮
// 可以在这个快照中通过搜索框快速找到某个类所包含的实例的个数等
// 销毁对象：给这个对象赋值为 null(原理：当没有任何东西能引用它时，它就会被销毁掉，谷歌的 v8 引擎也是这个原理)
</code></pre><h1 id="模块之间调用问题"><a href="#模块之间调用问题" class="headerlink" title="模块之间调用问题"></a>模块之间调用问题</h1><p>代码示例：</p>
<pre><code>// a.js
// console.log(&apos;a1&apos;);
// require(&apos;./b&apos;);
// console.log(&apos;a2&apos;);
// exports.num = 1;
// 结果：a1,b1,b2,a2

// b.js
// console.log(&apos;b1&apos;);
// //在requirea的时候返回一个临时的引用，未初始化完成的对象
// var a = require(&apos;./a&apos;);
// console.log(a);
// console.log(&apos;b2&apos;);
</code></pre><h6 id="Node-js-v8-9-0-文档"><a href="#Node-js-v8-9-0-文档" class="headerlink" title="Node.js v8.9.0 文档"></a><a href="http://nodejs.cn/api/" title="Node.js v8.9.0 文档" target="_blank" rel="noopener">Node.js v8.9.0 文档</a></h6><blockquote>
<p>本文来源: <a href="http://www.zhufengpeixun.cn" title="珠峰培训" target="_blank" rel="noopener">珠峰培训</a></p>
<p>珠峰培训课程代码: <a href="https://github.com/zhufengnodejs/201601node" target="_blank" rel="noopener">https://github.com/zhufengnodejs/201601node</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/20/Node-js之express框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/20/Node-js之express框架/" itemprop="url">Node.js之express框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-20T19:57:01+08:00">
                2017-12-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是-express"><a href="#什么是-express" class="headerlink" title="什么是 express ?"></a>什么是 express ?</h1><p><a href="http://www.expressjs.com.cn/4x/api.html" title="Express 4.x API 中文手册" target="_blank" rel="noopener">Express 4.x API 中文手册</a></p>
<p>express 是一个简洁、灵活的 node.js Web 应用开发框架,    它提供一系列强大的功能</p>
<ul>
<li>模板解析</li>
<li>静态文件服务</li>
<li>中间件</li>
<li>路由控制</li>
</ul>
<p>代码示例：</p>
<pre><code>//加载express
var express = require(&apos;express&apos;);
//获取配置对象
var app = express();
//配置路由
//当用户访问相应路径的时候，会执行后面的回调函数
app.get(&apos;/hello&apos;,function(req,res){
    //send它可以自动判断参数类型,自动转换响应信息
    //并且自动设置Content-Type
    res.end(&apos;get hello&apos;);
});
app.post(&apos;/hello&apos;,function(req,res){
    res.send(&apos;post hello&apos;);
});
app.all(&apos;/hello&apos;,function(req,res){
    res.send(&apos;all hello&apos;);
});
//启动服务器
app.listen(3000); // 绑定并监听指定主机和端口上的连接；这个方法和Node的http.Server.listen（）是一样的
</code></pre><h1 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h1><ul>
<li><p>get方法 —— 根据请求 <code>路径</code> 来处理客户端发出的请求</p>
<pre><code>app.get(path,function(request, response)); 
</code></pre></li>
<li>path为请求的 <code>路径</code></li>
<li>第二个参数为处理请求的 <code>回调函数</code>，有两个参数分别是request和response，代表请求信息和响应信息</li>
<li>app.all()函数可以匹配所有的HTTP <code>动词</code>，也就是说它可以匹配所有路径的请求</li>
</ul>
<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><ul>
<li>中间件就是处理HTTP请求的 <code>函数</code>，用来完成各种特定的任务，比如检查用户是否登录、添加公共方法</li>
<li>它最大的特点就是，一个中间件处理完，可以把相应数据再传递给下一个中间件</li>
<li><p>如果调用回调函数的 <code>nest</code> 参数表示将请求数据传递给下一个中间件</p>
<pre><code>app.use([path], function(request, response, next){}); //可选参数path默认为&quot;/&quot;
</code></pre></li>
</ul>
<p>代码示例：</p>
<pre><code>//加载express
var express = require(&apos;express&apos;);
//获取配置对象
var app = express();
//计算一个处理请求一共花了多少时间
app.use(function(req,res,next){
   res.start  = Date.now(); // 开始时间
    //console.time(&apos;cost&apos;);
    //暂存原来的end方法
   var originalEnd = res.end;
    //为res.end重新赋值为我们自定义函数
    res.end = function(){
        //先把原来的end方法调用一次
        originalEnd.apply(res,Array.prototype.slice.call(arguments));
        //加入自己的小逻辑
        // console.timeEnd(&apos;cost&apos;); // console.time(&apos;cost&apos;); console.timeEnd(&apos;cost&apos;); 这种方式来计算执行时间在高并发时候是不行的，
        // 因为这个方法是全局唯一的，后面的会覆盖前面的
       console.log(&apos;timecost&apos;,Date.now() - res.start); // 通过重写 res.end() 方法，在重写的方法里面仍然调用了原来的 res.end() 方法，
       // 但是也添加了对于执行时间的计算，这种方式每来一个请求就会新建一个响应对象(res)，彼此不冲突，也就不存在覆盖的现象
    }
    next();
});
//中央
app.use(&apos;/money&apos;,function(req,res,next){
    res.mny = 100;
    next();
});

//省里
app.use(&apos;/hello&apos;,function(req,res,next){
    res.mny = res.mny - 10;
    next();
});

//市里
app.use(&apos;/money&apos;,function(req,res,next){
    res.mny = res.mny - 30;
    next();
});
//村
app.use(function(req,res,next){
    res.mny = res.mny - 60;
    res.send(404); // 当参数位数字时作为响应状态码
    // 中间件里面的 res.send() 方法内参数不能为状态码以外的数字(会报错)，因为在老版本中会以为它是一个状态码，
    // 为了避免歧义，在新版本中返回状态码使用 res.sendStatus 方法
});

//发送补贴100
app.get(&apos;/money&apos;,function(req,res){
    res.send(&quot;&quot;+res.mny);
});

app.listen(8080);
</code></pre><h1 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h1><ul>
<li>req.host返回请求头里的 <code>主机名</code> (不包含端口号)</li>
<li>req.path返回请求的URL的 <code>路径名</code></li>
<li>req.query是一个可获取客户端get请求认 <code>查询字符串</code> 转成的对象，默认为{}</li>
<li>req.params是一个由 <code>路径参数</code> 组成的对象</li>
</ul>
<p>代码示例：</p>
<pre><code>var express = require(&apos;express&apos;);
//获取配置对象
var app = express();
// localhost:8080/hello?name=zfpx
app.get(&apos;/hello&apos;,function(req,res){
    //var urlObj = url.parse(req.url,true);

    console.log(req.host);//主机名
    console.log(req.path);// 路径 urlObj.pathname
    console.log(req.query);// urlObj.query
    res.send(&apos;欢迎来到首页&apos;);
});
//路径参数 把向服务器端传递的参数放在路径里
app.get(&apos;/user/:id/:age&apos;,function(req,res){
    console.log(req.params.id);
    console.log(req.params.age);
    console.log(req.host);
    console.log(req.path);
    console.log(req.query);
    res.send(&apos;欢迎来到user&apos;);
});

app.listen(8080);
</code></pre><h1 id="send-方法"><a href="#send-方法" class="headerlink" title="send 方法"></a>send 方法</h1><p>send() 方法向浏览器发送响应，并可以智能处理不同类型的数据。并且输出响应时会自动进行一些设置，比如header信息、http缓存支持等等</p>
<ul>
<li><p>当参数为一个String时，Content-Type默认设置为”text/html”</p>
<pre><code>res.send([body|status], [body]);
</code></pre></li>
<li><p>当参数为Array或Object时，Express会返回一个JSON</p>
<pre><code>res.send({ user: &apos;tobi&apos; }); //{&quot;user&quot;:&quot;tobi&quot;}
</code></pre></li>
<li>不能使用数字作为参数，如果要返回入码要用 <code>res.sendStatus</code> 方法</li>
</ul>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><ol>
<li><p>1.指定渲染模板引擎</p>
<pre><code>app.set(&apos;view engine&apos;,&apos;ejs&apos;);
</code></pre></li>
<li><p>2.设置放模板文件的目录</p>
<pre><code>app.set(&apos;views&apos;,path.join(__dirname,&apos;/&apos;));
</code></pre></li>
<li><p>render函数，对网页模板进行渲染 在渲染模板时<strong>locals</strong>可为其模板传入变量值，在模板中就可以调用所传变量了</p>
<pre><code>res.render(view, [locals], callback);
</code></pre></li>
<li><p>原理</p>
<pre><code>var tmpl = &apos;&lt;h1&gt;{{name}}&lt;/h1&gt;&lt;h1&gt;{{age}}&lt;/h1&gt;&apos;; 
var data = {name:&apos;zfpx&apos;,age:30};
var html= tmpl.replace(/\{\{(\w+)\}\}/g,function(input,group){ 
    return data[group];
})
</code></pre></li>
</ol>
<blockquote>
<p>渲染模板：obj[attr] 其中 attr 可以是不带引号的属性名，当然也可以通过 ‘.’ 来获取属性值</p>
</blockquote>
<p>代码示例：</p>
<pre><code>var express = require(&apos;express&apos;);
var path = require(&apos;path&apos;);
var app = express();
/**
 * 1. 动态内容 当前时间
 * 2. 静态内容  tmpl.html
 * 3. 动静结合
 */
//配置属性值
//配置模板引擎
// 模板引擎:jade ejs
app.set(&apos;view engine&apos;,&apos;ejs&apos;);
//指定模板存放的目录
// resolve 先获取当前文件的所在在绝对目录 ，然后再拼上后面的参数
app.set(&apos;views&apos;,path.resolve(&apos;views&apos;));

// app.set() 方法在指定模板存放的目录时使用 path.resolve() 方法比 通过 process.cwd()+&apos;模板文件夹&apos; 这种方式要好一点，
// 因当前工作路径可能会因为 process.chdir() 方法更改，但是当前文件所在路径(模板文件夹的所在路径)是不会变的，所以应该使用 path.resolve() 方法，
// 或者使用 __diename+&apos;文件夹名&apos; 来得到绝对路径

app.get(&apos;/&apos;,function(req,res){
    //把模板和数据混合成HTML页面
    res.render(&apos;index.ejs&apos;,{title:&apos;首页&apos;,books:{
        name:&apos;node.js&apos;
    }});
});
app.get(&apos;/reg&apos;,function(req,res){
    res.render(&apos;index&apos;,{title:&apos;注册&apos;});
});
app.listen(8080);



//render 渲染模板原理
function render(tmpl,data){
    //用真实的值替换占位变量
    return tmpl.replace(/\{\{(\w+)\}\}/,function(matched,group1){
        console.log(arguments);
        return data[group1];
    })
}//把模板里的变量替换成对象里的属性，变量和属性名一定要相同
var result = render(&apos;&lt;h1&gt;{{title}}&lt;/h1&gt;&apos;,{title:&apos;欢迎&apos;});
console.log(result);




//tmpl.html

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;珠峰培训&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%=title%&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h1 id="静态文件服务中间件"><a href="#静态文件服务中间件" class="headerlink" title="静态文件服务中间件"></a>静态文件服务中间件</h1><p>express.static 是 Express 内置的唯一一个中间件,负责托管 Express 应用内的静态资源</p>
<ul>
<li>如果要在网页中加载静态文件（css、js、img），就需要另外指定一个存放静态文件的 <strong>目录</strong></li>
<li>项目目录下添加一个存放静态文件的目录为 <code>public</code></li>
<li>在public目录下再添加三个存放 <code>js</code>、<code>css</code>、<code>img</code>的目录,把相关文件放到相应的目录下</li>
<li>当浏览器发出文件请求时，服务器端就会到这个目录下去寻找相关文件</li>
</ul>
<blockquote>
<p>静态文件服务中间件的原理其实就是把请求路径中的 ‘/‘ 替换成你指定的存放静态文件的文件夹，你放访问的文件都是在这个文件夹下面去查找的，如果查找不到就会返回无法找到文件的提示</p>
</blockquote>
<pre><code>app.use(express.static(require(&apos;path&apos;).join(     dirname, &apos;public&apos;)),{options});
</code></pre><p>代码示例：</p>
<pre><code>var express = require(&apos;express&apos;);
var path = require(&apos;path&apos;);
var fs = require(&apos;fs&apos;);
var app = express();
/*app.use(function(req,res,next){
    fs.createReadStream(__dirname+&apos;/public&apos;+req.url).pipe(res);
});*/
//参数的值是静态文件目录的根目录
app.use(express.static(__dirname+&apos;/public&apos;));

app.listen(8080);
</code></pre><h1 id="post-方法"><a href="#post-方法" class="headerlink" title="post 方法"></a>post 方法</h1><p>根据请求路径来处理客户端发出的Post请求</p>
<pre><code>var bodyParser = require(&apos;body-parser&apos;); 
app.use(bodyParser.urlencoded({extended:true})); 
app.post(path,function(req, res));
</code></pre><p><code>req.body</code> 属性解析客户端的 post 请求参数，通过它可获取请求路径的参数值</p>
<blockquote>
<p>express.post() 方法获取请求体中的内容时需要使用 body-parser 模块，该模块的实现是通过监听 data 和 end 事件将请求体中的数据得到，并且会根据请求头中的 Content-Type 的类型来判断应该使用那种方式来解析数据；例如：当类型为 application/x-www-form-urlencoded 时，需要使用 bodyParser.uelencoded() 方法来解析查询字符串形式的数据，其他类型的数据也需要相应的解析方法来解析数据</p>
</blockquote>
<p>代码示例：</p>
<pre><code>var express = require(&apos;express&apos;);
var bodyParser = require(&apos;body-parser&apos;);
var app = express();
app.use(express.static(__dirname));
//extended 为true时，用querystring,如果为false会用bodyParser自己的转换方法
// 如果请求头里的content-type是application/x-www-form-urlencoded, 会用此中间件转成对象放到req.body上，否则 什么都不做
app.use(bodyParser.urlencoded({extended:true}));//此中间件会把请求体提取出来放到req.body上
//如果请求头里的content-type是application/json的时候，, 会用此中间件转成对象放到req.body上，否则 什么都不做
//app.use(bodyParser.json());
app.post(&apos;/reg&apos;,function(req,res){
    //把请求体里的数据转变成对象放在req.body上
    console.log(req.body);
    res.end(&apos;reg&apos;);
});
app.listen(8080);




// reg.html

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;/reg&quot; method=&quot;post&quot;&gt;
    用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;
    密码: &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul>
<li>当中间件执行了 res.end() 方法后只是结束了对客户端的响应，后面仍然可以执行服务端自己的代码</li>
<li>安装模块时也会一并把依赖模块安装</li>
<li>3.0以前的老版本 node_modules 中的模块是一个模块包含一个 node_modules 的，里层的模块如果也有依赖的话，也会有一个 node_modules，即有嵌套关系；现在的新版本所有的模块都是统一在一个 node_modules 下的</li>
</ul>
<h6 id="Node-js-v8-9-0-文档"><a href="#Node-js-v8-9-0-文档" class="headerlink" title="Node.js v8.9.0 文档"></a><a href="http://nodejs.cn/api/" title="Node.js v8.9.0 文档" target="_blank" rel="noopener">Node.js v8.9.0 文档</a></h6><blockquote>
<p>本文来源: <a href="http://www.zhufengpeixun.cn" title="珠峰培训" target="_blank" rel="noopener">珠峰培训</a></p>
<p>珠峰培训课程代码: <a href="https://github.com/zhufengnodejs/201601node" target="_blank" rel="noopener">https://github.com/zhufengnodejs/201601node</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/19/Node-js之代理跨域-proxy-cross-domain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/19/Node-js之代理跨域-proxy-cross-domain/" itemprop="url">Node.js之代理跨域_proxy_cross_domain</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-19T19:16:16+08:00">
                2017-12-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a>跨域资源共享</h1><ul>
<li>XHR2中浏览器选择允许发送合适的CORS(cross-origin resource sharing，跨域资源共享)来 <code>跨域请求数据</code></li>
<li>在标准浏览器中依旧使用 <code>XMLHttpRequest</code> 对象</li>
</ul>
<h1 id="设置响应头"><a href="#设置响应头" class="headerlink" title="设置响应头"></a>设置响应头</h1><ul>
<li><p>当浏览器使用跨域资源共享时，服务器都必须在响应头中设置</p>
<pre><code>response.writeHead(200,{&quot;Access-Control-Allow-Origin&quot;:&quot;*&quot;})
</code></pre></li>
<li><p>其中 <code>＊</code> 代码允许任何源请求本服务器. 也可以改成固定的源。例如：</p>
<pre><code>{&quot;Access-Control-Allow-Origin&quot;:&quot;http://localhost:63342&quot;}
</code></pre></li>
<li>只允许URL为 <code>http://localhost:63342</code> 的请求源请求本服务器</li>
</ul>
<h1 id="withCredentials属性"><a href="#withCredentials属性" class="headerlink" title="withCredentials属性"></a>withCredentials属性</h1><ul>
<li>默认情况下，在浏览器中使用供 <code>XMLHttpRequest</code> 进行跨源请求不提凭据(cookie等)</li>
<li>通过将 <code>XMLHttpRequest</code> 的 <code>withCredentials</code> 的属性设置为 <code>true</code> ,可以指定某个请求应该发送凭据</li>
<li><p>如果服务器接收带凭据的请求，会用下面的HTTP头部来响应</p>
<pre><code>//服务器端返回此响应头
Access-Control-Allow-Credentials: true

//在客户端XMLHttpRequest的withCredentials设置为true
xhr.withCredentials=true;
</code></pre><blockquote>
<p>警告： 如果将 <code>XMLHttpRequest</code> 的 <code>withCredentials</code> 属性设置为 <code>true</code> 的时候，<br><code>Access-Control-Allow-Origin</code> 这个响应头不可以设置为* </p>
</blockquote>
</li>
</ul>
<h1 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h1><blockquote>
<p>服务端和客户端都不需要进行任何更改，只是中间的代理部分来衔接服务端可客户端；这个过程其实对于客户端来说是透明的，客户端会以为它访问的依然是自己原来访问的资源，其实中间代理已经给它的请求做了相应的处理(这里代理跨域其实就是代理客户端进行了跨域请求)</p>
</blockquote>
<p>bodyParser.js(可读流方法的封装)</p>
<pre><code>module.exports = function(req,callback){
    var result = &apos;&apos;;
    req.on(&apos;data&apos;,function(data){
        result+=data;
    });
    req.on(&apos;end&apos;,function(){
        callback(result);
    });
}
</code></pre><p>proxy.js(代理服务器)</p>
<pre><code>var http = require(&apos;http&apos;);
var fs = require(&apos;fs&apos;);
var bodyParser = require(&apos;./bodyParser&apos;);
var proxy = require(&apos;./request&apos;);
var server = http.createServer(function (req, res) {
    if (req.url == &apos;/&apos;) {
        fs.createReadStream(&apos;./index.html&apos;).pipe(res);
    } else if (req.url == &apos;/reg&apos;) {
        //1. 获取请求里的请求体
        //2. 构建一个指向8080的请求，把请求体传递过去
        //3 .得到8080的响应，然后再传回客户端
        bodyParser(req, function (result) {
            proxy({
                host: &apos;localhost&apos;,
                port: 8080,
                path: &apos;/&apos;,
                method: &apos;POST&apos;,
            }, result, function (response) {
                res.end(response);
            });

        })
    }

}).listen(9090);
</code></pre><p>request.js(客户端的请求)</p>
<pre><code>var bodyParser = require(&apos;./bodyParser&apos;);
var http = require(&apos;http&apos;);
/**
 *
 * @param options 访问真正服务器的配置对象
 * @param data 请求体的数据
 * @param callback 取得真正服务器响应后的回调函数
 */
module.exports = function(options,data,callback){
   //向真正的数据服务器发送请求 res代表服务器的响应
    var request = http.request(options,function(res){
        bodyParser(res,function(result){
            callback(result);
        });
    });
    //向服务器发送请求体
    request.end(data);
}
</code></pre><p>trueserver.js(真正需要访问的服务器)</p>
<pre><code>var http = require(&apos;http&apos;);
var fs = require(&apos;fs&apos;);
var users = [];
var server = http.createServer(function (req, res) {
    var result = &apos;&apos;;
    req.on(&apos;data&apos;,function(data){
        result+=data;
    })
    req.on(&apos;end&apos;,function(data){
        users.push(JSON.parse(result));
        //设置响应头，允许哪个来源来访问我这个服务器
        // res.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;http://localhost:*&apos;);
        // res.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;http://localhost:63342&apos;);
        res.end(JSON.stringify(users));
    })

}).listen(8080);
</code></pre><h6 id="Node-js-v8-9-0-文档"><a href="#Node-js-v8-9-0-文档" class="headerlink" title="Node.js v8.9.0 文档"></a><a href="http://nodejs.cn/api/" title="Node.js v8.9.0 文档" target="_blank" rel="noopener">Node.js v8.9.0 文档</a></h6><blockquote>
<p>本文来源: <a href="http://www.zhufengpeixun.cn" title="珠峰培训" target="_blank" rel="noopener">珠峰培训</a></p>
<p>珠峰培训课程代码: <a href="https://github.com/zhufengnodejs/201601node" target="_blank" rel="noopener">https://github.com/zhufengnodejs/201601node</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/19/Node-js之node客户端-nodeclient/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/19/Node-js之node客户端-nodeclient/" itemprop="url">Node.js之node客户端_nodeclient</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-19T17:56:57+08:00">
                2017-12-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="创建-http-客户端"><a href="#创建-http-客户端" class="headerlink" title="创建 http 客户端"></a>创建 http 客户端</h1><p><code>request</code> 方法可以向其他网站请求数据</p>
<ul>
<li><p>options</p>
<ul>
<li><p>host </p>
<p>  <strong>域名</strong>或目标主机IP</p>
</li>
<li><p>hostname </p>
<p>  <strong>域名</strong>或目标主机，优先级比 host 高</p>
</li>
<li><p>port </p>
<p>  <strong>端口</strong>号</p>
</li>
<li><p>method </p>
<p>  请求<strong>方法</strong></p>
</li>
<li><p>path</p>
<p>  请求的<strong>路径</strong>，默认为 <code>/</code></p>
</li>
<li><p>headers</p>
<p>  客户端请求<strong>头对象</strong></p>
</li>
<li><p>auth</p>
<p>  <strong>认证</strong>信息，如 “username:password”</p>
</li>
</ul>
</li>
<li>callback = function(response) {}<br>当<strong>获取</strong>到目标网站所返回的<strong>响应流</strong>时调用的回调函数<ul>
<li><code>response</code> 是一个 http.IncomingMessage 对象，可以从中 <code>读</code></li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code>var http = require(&apos;http&apos;);
//指定请求的参数
var options = {
    host:&apos;localhost&apos;,
    port:8080,
    path:&apos;/post&apos;,
    method:&apos;POST&apos;,
    //headers:{&apos;Content-Type&apos;:&apos;application/json&apos;}
    //headers:{&apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;}
    headers:{&apos;Content-Type&apos;:&apos;application/zfpx&apos;}// 当服务端判断编码格式时，其实只要客户端和服务端约定好让服务端能够识别这种编码格式就行，
    // 所以你可以甚至使用这样的一种编码格式: application/zfpx;
    // 但是服务端一定要能明确知道这种编码是什么意思(即自定义格式)；但是 http 提供的格式最好按规范书写，不要随意篡改
}
//向服务器发送请求
var request = http.request(options,function(res){
     console.log(res.statusCode);//读取响应状态码
     console.log(res.headers);//读取响应头
    var result = &apos;&apos;;
    res.on(&apos;data&apos;,function(data){
        result+=data;
    })
    res.on(&apos;end&apos;,function(){
        var users = JSON.parse(result);
        console.log(users);
    });
})
// 有些对象既可以是 可读流，也可以是 可写流；
// 在 http 创建的服务端中 request 可读，response 可写； 在 http 创建的客户端中 response 可读，request 可写
// request也是一个流，是一个可写流
/*request.write(&apos;{&quot;name&quot;:&quot;zfpx&quot;&apos;);
request.write(&apos;,&quot;age&quot;:6}&apos;);*/
//request.write(&apos;name=zfpx&amp;age=6&apos;);
request.write(&apos;name@zfpx|age@6&apos;);
request.end();

// 三种编码格式对应的处理方式：
if(contentType ==&apos;application/json&apos;){
     user = JSON.parse(result);
} else if(contentType ==&apos;application/x-www-form-urlencoded&apos;){
  //name=zfpx&amp;age=6
   user = require(&apos;querystring&apos;).parse(result);
}else if(contentType ==&apos;application/zfpx&apos;){
    //name@zfpx|age@6
    user = require(&apos;querystring&apos;).parse(result,&apos;|&apos;,&apos;@&apos;);
}
</code></pre><p>也可参考代码： <a href="http://www.imooc.com/qadetail/181878" target="_blank" rel="noopener">http://www.imooc.com/qadetail/181878</a></p>
<h6 id="Node-js-v8-9-0-文档"><a href="#Node-js-v8-9-0-文档" class="headerlink" title="Node.js v8.9.0 文档"></a><a href="http://nodejs.cn/api/" title="Node.js v8.9.0 文档" target="_blank" rel="noopener">Node.js v8.9.0 文档</a></h6><blockquote>
<p>本文来源: <a href="http://www.zhufengpeixun.cn" title="珠峰培训" target="_blank" rel="noopener">珠峰培训</a></p>
<p>珠峰培训课程代码: <a href="https://github.com/zhufengnodejs/201601node" target="_blank" rel="noopener">https://github.com/zhufengnodejs/201601node</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/18/Node-js之流-stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/18/Node-js之流-stream/" itemprop="url">Node.js之流_stream</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-18T19:40:22+08:00">
                2017-12-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="fs-模块读写方法"><a href="#fs-模块读写方法" class="headerlink" title="fs 模块读写方法"></a><code>fs</code> 模块读写方法</h1><p><img src="/img/stream_fs.png" alt="stream_fs.png" title="stream_fs.png"></p>
<h1 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h1><p>fs 模块的读写方法都是 整体 读入或者写入的，这时候当一个文件过大时，就不能通过这种方式去操作了，因为内存的空间大小是有限的，当一个文件的大小超出了这个大小，就不能进行读写操作了(因为fs 的读写操作是文件整体通过内存中的缓存进行操作的)；这时就应该使用 流 来操作了</p>
<ul>
<li>流是一组 <code>有序</code> 的，有 <code>起点</code> 和 <code>终点</code> 的 <code>字节数据传输</code> 手段</li>
<li>不关心文件的整体内容，只关注是否从文件中 <code>读</code> 到了数据，以及读到数据之后的 <code>处理</code></li>
<li>流是一个 <code>抽象接口</code> ，被 Node 中的很多对象所实现。比如对一个HTTP 服务器的请求对象request是一个流，stdout 也是一个流</li>
</ul>
<blockquote>
<p>互联网数据传输的足校单位是 字节</p>
</blockquote>
<h1 id="stream-Readable-可读流"><a href="#stream-Readable-可读流" class="headerlink" title="stream.Readable 可读流"></a>stream.Readable 可读流</h1><p>使用实现了stream.Readable接口的对象来将对象数据读取为流数据,在<br>您表明您 <code>准备好</code> 接收之前，Readable 流并不会开始发射数据</p>
<h1 id="ReadStream-文件可读流"><a href="#ReadStream-文件可读流" class="headerlink" title="ReadStream 文件可读流"></a>ReadStream 文件可读流</h1><pre><code>fs.createReadStream(path,[options]);
</code></pre><ul>
<li>path: 读取的 <code>文件路径</code></li>
<li>options:<ul>
<li>-flags 对文件采取何种操作,默认为 ‘r’</li>
<li>-encoding 指定 <code>编码</code> ，默认为null；当不指定时，就不进行编码，就是一个 buffer(二进制数据)；如果指定了编码，就会是一个字符串，相当于调用了 buffer 对象的 toString 方法</li>
<li>-autoClose 读完数据后是否关闭文件描述符</li>
<li>-start 用整数表示文件 <code>开始</code> 读取的字节数的索引位置</li>
<li>-end 用整数表示文件 <code>结束</code> 读取的字节数的索引位置( 包括end位置 )</li>
<li>highWaterMark 最高水位线，停止从底层资源读取前内部缓冲区最多能存放的字节数(其实就是触发一次 data 事件处理数据内容的大小)。缺省为 64kb</li>
</ul>
</li>
</ul>
<h1 id="可读流触发的-事件"><a href="#可读流触发的-事件" class="headerlink" title="可读流触发的 事件"></a>可读流触发的 事件</h1><p><img src="/img/readstream_events.png" alt="readstream_events.png" title="readstream_events.png"></p>
<h1 id="可读流的方法"><a href="#可读流的方法" class="headerlink" title="可读流的方法"></a>可读流的方法</h1><p><img src="/img/readstream_funcs.png" alt="readstream_funcs.png" title="readstream_funcs.png"></p>
<p>可读流示例：</p>
<pre><code>var fs  = require(&apos;fs&apos;);
//创建可读流
var rs = fs.createReadStream(&apos;./index.txt&apos;,{
    start:3,
    end:8,
    highWaterMark:4
});

//设置编码
rs.setEncoding(&apos;utf8&apos;);
//监听data事件，当读到数据的时候会触发data事件
// pause 通知对象 停止 触发data 事件(停止喂)
// resume 通知对象 恢复 触发data 事件(恢复接着喂)
rs.on(&apos;data&apos;,function(data){
    //吃一口先要求暂停
    rs.pause();
   setTimeout(function(){
        console.log(data);
       //要求接着喂
       rs.resume();
   },1000)
})
//从文件中读取完毕之后会触发end事件
rs.on(&apos;end&apos;,function(){
    console.log(&apos;end&apos;);
})
//当读取文件出错的时候会触发error事件
rs.on(&apos;error&apos;,function(err){
    console.error(err);
})
/**
 * 处理错误的方式：    
 * 1. 同步方法 try catch
 * 2. 异步 判断回调函数里的error对象是否有值
 * 3. 在流里判断错误，监听 它的 error事件
 **/
</code></pre><h1 id="Writable-可写流"><a href="#Writable-可写流" class="headerlink" title="Writable 可写流"></a>Writable 可写流</h1><p>使用各种实现stream.Writable接口的对象来将流数据 <code>写入</code> 到对象中</p>
<blockquote>
<p>response 就是一个 可写流，同样拥有 write 和 end 方法</p>
</blockquote>
<h1 id="可写流的方法"><a href="#可写流的方法" class="headerlink" title="可写流的方法"></a>可写流的方法</h1><p><img src="/img/writable_funcs.png" alt="writable_funcs.png" title="writable_funcs.png"></p>
<h1 id="WriteStream"><a href="#WriteStream" class="headerlink" title="WriteStream"></a>WriteStream</h1><p>在fs模块中使用 <code>createWriteStream</code> 方法创建一个将流数据写入文件中的 <code>WriteStream</code> 对象</p>
<pre><code>fs.createWriteStream(path,[options]);
</code></pre><ul>
<li>path: 读取的文件路径</li>
<li>options:<ul>
<li>-flags 对文件采取何种 <code>操作</code> ,默认为 ‘w’</li>
<li>-encoding 指定 <code>编码</code> ，默认为null</li>
<li>-autoClose 是否 <code>关闭</code> 文件描述符</li>
<li>-start 用整数表示文件 <code>开始</code> 字节数的写入位置</li>
<li>-highWaterMark 最高水位线，write()开始返回 false 的 <code>缓冲大小</code> (其实就是一次写入的内容大小，默认是 16kb，当一次写入数据的内容小于这个值，write() 方法会返回 true，否则返回 false)。缺省为 16kb</li>
</ul>
</li>
</ul>
<h1 id="write-方法"><a href="#write-方法" class="headerlink" title="write 方法"></a>write 方法</h1><pre><code>writable.write(chunk,[encoding],[callback]);
</code></pre><ul>
<li>参数<ul>
<li>-chunk 要 <code>写入</code> 的数据，Buffer或字符串对象，必须指定</li>
<li>-encoding 写入 <code>编码</code> ，chunk为字符串时有用，可选</li>
<li>callback 写入成功后的 <code>回调</code></li>
</ul>
</li>
<li>返回值为布尔值，系统缓存区定满时为false,未满时为true</li>
</ul>
<h1 id="end-方法"><a href="#end-方法" class="headerlink" title="end 方法"></a>end 方法</h1><p>在写入文件时，当不再需要写入数据时可调用该方法关闭文件。 迫使系统缓存区的数据立即写入文件中</p>
<p>可写流示例：</p>
<pre><code>writable.end(chunk,[encoding],[callback]);

var fs = require(&apos;fs&apos;);

var ws = fs.createWriteStream(&apos;./write.txt&apos;,{});
//写入
ws.write(&apos;好&apos;,&apos;utf8&apos;,function(err){
    console.log(1);
})
ws.write(&apos;好&apos;,&apos;utf8&apos;,function(err){
    console.log(2);
})
ws.write(&apos;好&apos;,&apos;utf8&apos;,function(err){
    console.log(3);
})
//写入并且关闭
ws.end(&apos;学习&apos;,&apos;utf8&apos;);
</code></pre><h1 id="通过-可读流-和-可写流-实现-copy-方法"><a href="#通过-可读流-和-可写流-实现-copy-方法" class="headerlink" title="通过 可读流 和 可写流 实现 copy 方法"></a>通过 可读流 和 可写流 实现 <code>copy</code> 方法</h1><pre><code>function copy(src,target){
    var rs = fs.createReadStream(src);
    var ws = fs.createWriteStream(target);
    rs.on(&apos;data&apos;, function (data) {
        ws.write(data);
    });

    rs.on(&apos;end&apos;, function (data) {
        ws.end();
    });
}
</code></pre><h1 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h1><p>流，尤其是 pipe() 方法的初衷，是将数据的 <code>滞留量</code> 限制到一个可接受的水平，以使得不同速度的来源和目标不会 <code>淹没</code> 可用内存</p>
<pre><code>readStream.pipe(writeStream,[options]);
</code></pre><ul>
<li>readStream可读流对象</li>
<li>writeStream可写流对象</li>
<li>options<ul>
<li>end 为true时表示数据读取完毕后立刻将缓存区中的数据写入目标文件并 <code>关闭</code> 文件</li>
</ul>
</li>
</ul>
<p>pipe 示例：</p>
<pre><code>var fs = require(&apos;fs&apos;);
function copy(src,target){
    var rs = fs.createReadStream(src);
    var ws = fs.createWriteStream(target);
    //对文件写和读的时候
    //要先打开文件，然后读写文件，然后关闭文件
    rs.pipe(ws,{end:true});

}
function pipe(source,dest){
    //先监听可流的data事件，
    source.on(&apos;data&apos;, function(chunk) {
        //写成功就是true,写失败就是false
        if(false === dest.write(chunk)){
            //停止触发data事件
            source.pause();
        }
    });

    //监听目标可写流的 drain 事件，当目标可写流里所有需要缓冲的写入操作都完毕后，将流重新切换回流动模式(当全部咽下之后，调用回调函数)
    dest.on(&apos;drain&apos;, function(){
        //重新开始触发data事件
        source.resume();
    });

}
copy(&apos;./index.txt&apos;,&apos;./write.txt&apos;);
</code></pre><h6 id="Node-js-v8-9-0-文档"><a href="#Node-js-v8-9-0-文档" class="headerlink" title="Node.js v8.9.0 文档"></a><a href="http://nodejs.cn/api/" title="Node.js v8.9.0 文档" target="_blank" rel="noopener">Node.js v8.9.0 文档</a></h6><blockquote>
<p>本文来源: <a href="http://www.zhufengpeixun.cn" title="珠峰培训" target="_blank" rel="noopener">珠峰培训</a></p>
<p>珠峰培训课程代码: <a href="https://github.com/zhufengnodejs/201601node" target="_blank" rel="noopener">https://github.com/zhufengnodejs/201601node</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/17/Node-js之跨域请求-jsonp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/17/Node-js之跨域请求-jsonp/" itemprop="url">Node.js之跨域请求_jsonp</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-17T21:52:15+08:00">
                2017-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>同源策略就是规定了javascript 可以操作 那些web内容的一个完整的安全限制</p>
<p>ajax属于同源策略<br>jsonp属于非同源策略（跨域请求）-&gt;实现跨域请求的方式有很多种，只不过jsonp是最常用的</p>
<h1 id="什么是同源？"><a href="#什么是同源？" class="headerlink" title="什么是同源？"></a>什么是同源？</h1><p>同源就是规定多个 web 资源的 url 中 <code>scheme(协议)</code> 、<code>hostname(域名或IP)</code> 、<code>port(端口)</code> 必须相同，用当前页面的URL地址 对比 数据请求的接口地址只要有一项不同那么这个 <code>web</code> 资源就不是同源的；</p>
<p>以上三部分完全相同属于同源策略，我们使用ajax技术获取数据；只要有一个不一样的，就属于非同源，我们一般使用jsonp获取数据</p>
<h1 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h1><p>当请求的资源的 URL 与 当前页面 的 URL 中的 <code>hostname(域名或IP)</code> 、<code>port(端口)</code> 有一个不同的时候就算是跨域操作</p>
<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>jsonp和ajax相同，都是客户端向服务器端发送请求：给服务器端传递数据 或者 从服务器端获取数据 的方式</p>
<ul>
<li>script 元素可以作为一种 Ajax 传输协议</li>
<li>只需设置 script 元素的 <code>src</code> 属性并且插入到 DOM 中，浏览器就会发<br>出一个 HTTP 请求到 src 属性所指向的 URL </li>
<li>script不受 同源策略 的影响</li>
<li>script元素会 自动下载 并 执行 下载的数据</li>
<li><p>使用这种script元素来进行 Ajax 数据的传输的技术就叫做 JSONP ,也<br>就是 <code>JSON with Padding</code></p>
<pre><code>//服务器不可以返回这样的数据[&quot;baidu&quot;,&quot;telnet&quot;,&quot;alibaba&quot;]
//服务器会返回一个这样的响应
functionName([&quot;baidu&quot;,&quot;telnet&quot;,&quot;alibaba&quot;])
</code></pre></li>
</ul>
<blockquote>
<p>其中的 functionName 必须是在 window 下可以访问的名称</p>
</blockquote>
<h1 id="jsonp的原理（jsonp请求一定需要对方的服务器做支持才可以）："><a href="#jsonp的原理（jsonp请求一定需要对方的服务器做支持才可以）：" class="headerlink" title="jsonp的原理（jsonp请求一定需要对方的服务器做支持才可以）："></a>jsonp的原理（jsonp请求一定需要对方的服务器做支持才可以）：</h1><ul>
<li>在script的世界中，没有同源跨域这一说，只要你给我src属性中的地址是一个合法的地址，script都可以把对应的内容请求回来</li>
<li>jsonp就是利用了script的这个原理<ol>
<li>我们首先需要把请求数据的那个跨域的API数据接口的地址，赋值给script的src属性</li>
<li>把当前页面中的某一个函数名当做参数值，传递给（这里以腾讯服务器为例）腾讯的服务器（URL问号传参，一般这么写：?callback=fn[callback是参数名]，之前有？了就不能写？了，而是使用&amp;，而且参数名一般为callback，因为函数名是不固定的，如果连参数名都不固定的话，人家就不知道哪个参数名里面的值是你传递过去的函数名了；如果客户端和服务器端保持统一使用了相同的名称，那么不用callback也是可以的）</li>
<li>腾讯服务器接收到你的请求后，需要进行特殊的处理：把你传递进来的函数名和它要给你的数据拼接成一个字符串<br>例如：我们传递进去的函数名是fn（函数名可以任意指定），它准备好的数据是’fn({“name”:”zhufeng})’-&gt;’我传递的函数名(需要给我们的数据)’</li>
<li>最后腾讯的服务器把准备好的数据通过http协议返回给我们客户端，客户端发现其实就是让我们的fn执行，而且还给fn传递了一堆数据，那些数据就是我们想要的</li>
</ol>
</li>
</ul>
<h1 id="ajax同源请求"><a href="#ajax同源请求" class="headerlink" title="ajax同源请求"></a>ajax同源请求</h1><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;ajax同源请求&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var xhr = new XMLHttpRequest;
    xhr.open(&quot;get&quot;, &quot;data.txt&quot;, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 &amp;&amp; xhr.status == 200) {//xhr.status一般为200，这里这么写只是为了方便，一般应该严格使用正则去匹配来判断
            console.log(xhr.responseText);
        }
    };
    xhr.send(null);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h1 id="JSONP-跨域请求"><a href="#JSONP-跨域请求" class="headerlink" title="JSONP 跨域请求"></a>JSONP 跨域请求</h1><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;jsonp跨域请求&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--不能在第一个script标签中的src属性中写入请求数据地址，会报错（fn is not defined），应该在第二个script标签中操作--&gt;
&lt;script charset=&quot;utf-8&quot; type=&quot;text/javascript&quot;&gt;
    function fn(data) {
        console.log(data);
    }
&lt;/script&gt;
&lt;script charset=&quot;utf-8&quot; type=&quot;text/javascript&quot;
        src=&quot;http://matchweb.sports.qq.com/kbs/calendar?columnId=100000&amp;callback=fn&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h1 id="模拟jsonp请求的服务器server-js"><a href="#模拟jsonp请求的服务器server-js" class="headerlink" title="模拟jsonp请求的服务器server.js"></a>模拟jsonp请求的服务器server.js</h1><pre><code>var http = require(&quot;http&quot;), fs = require(&quot;fs&quot;), url = require(&quot;url&quot;);
var server = http.createServer(function (request, response) {
    var urlObj = url.parse(request.url, true);
    var pathname = urlObj.pathname;
    var query = urlObj.query;//存储的是客户端请求的URL地址中问号传参后面的信息（并且是以对象的键值对方式存储的） {id:xx}
    var reg = /\.(html|css|js|json|txt|ico)/i;
    if (reg.test(pathname)) {
        var suffix = reg.exec(pathname)[1].toUpperCase();
        var suffixMIME = &quot;text/plain&quot;;
        switch (suffix) {
            case &quot;HTML&quot;:
                suffixMIME = &quot;text/html&quot;;
                break;
            case &quot;CSS&quot;:
                suffixMIME = &quot;text/css&quot;;
                break;
            case &quot;JS&quot;:
                suffixMIME = &quot;text/javascript&quot;;
                break;
            case &quot;JSON&quot;:
                suffixMIME = &quot;application/json&quot;;
                break;
            case &quot;ICO&quot;:
                suffixMIME = &quot;application/octet-stream&quot;;
                break;
        }
        try {
            var con = fs.readFileSync(&quot;.&quot; + pathname, &quot;utf-8&quot;);
            response.writeHead(200, {&quot;content-type&quot;: suffixMIME + &quot;;charset=utf-8:&quot;});
            response.end(con);
        } catch (e) {
            response.writeHead(404, {&quot;content-type&quot;: &quot;text/plain;charset=utf-8:&quot;});
            response.end(&quot;file is not found!&quot;);
        }
    }
    //jsonp的处理
    if (pathname === &quot;/getAll&quot;) {
        //接收客户端传递进来的函数名
        var fnName = query[&quot;callback&quot;];
        //准备数据
        var con = fs.readFileSync(&quot;./customer.json&quot;, &quot;utf-8&quot;);
        //返回给客户端的内容
        response.writeHead(200, {&quot;content-type&quot;: &quot;text/javascript;charset=utf-8;&quot;});//注意：类型要为text/javascript，这样客户端才会把返回的内容按照js代码来解析，也就才会有函数执行
        response.end(fnName + &quot;(&quot; + con + &quot;)&quot;);//理论上来说con可以是其他格式的数据（任何它想要返回的），比如：一般格式的字符串，json格式的字符串，数字，xml格式字符串...但是一般返回给客户端的是json格式的字符串
        //里面不管传了几个参数，在客户端都一样执行：response.end(fnName + &quot;(&quot; + con + &quot;,100)&quot;);这种情况下只要客户端也声明了第二个参数来接收这个100，就同样能获取到
    }
});
server.listen(8080, function () {
    console.log(&quot;server is created success,listening on 8080 port!&quot;);
});
</code></pre><h1 id="jquery的ajax和jsonp的调用"><a href="#jquery的ajax和jsonp的调用" class="headerlink" title="jquery的ajax和jsonp的调用"></a>jquery的ajax和jsonp的调用</h1><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;42-2jquery的ajax和jsonp的调用&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script charset=&quot;UTF-8&quot; type=&quot;text/javascript&quot; src=&quot;../js/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt;
&lt;script charset=&quot;UTF-8&quot; type=&quot;text/javascript&quot;&gt;
    //ajax
    $.ajax({
        url: &quot;data.txt&quot;,
        type: &quot;get&quot;,
        dataType: &quot;json&quot;,
        data: null,
        async: true,
        timeout: 1000,//设置超时时间，一般都设定为3000ms；如果在设置的时间内没有请求成功，就会执行error这个方法
        cache: false,//设定为get请求方式时不走缓存数据，原理其实就是在URL的末尾加随机数，默认是true
        success: function () {

        },//请求成功会执行success这个方法
        error: function () {

        }//请求失败会执行error这个方法
    });

    //jsonp都是get和异步请求的，不存在其他的请求方式和同步请求，而且jQuery默认就会给jsonp的请求清除缓存
    //jsonp     http://matchweb.sports.qq.com/kbs/calender?columnId=100000
    $.ajax({
        url: &quot;http://matchweb.sports.qq.com/kbs/calender?columnId=100000&quot;,
        dataType: &quot;jsonp&quot;,
        jsonCallback: &quot;fn&quot;,//自定义传递给服务器的函数名，而不是使用jQuery自动生成的
        jsonp: &quot;cb&quot;,//把传递函数名的那个形参callback变为cb
        success: function () {

        }
    });
    //最后请求的地址变为了：
    //http://matchweb.sports.qq.com/kbs/calender?columnId=100000&amp;cb=fn&amp;_=1470108587279
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h6 id="Node-js-v8-9-0-文档"><a href="#Node-js-v8-9-0-文档" class="headerlink" title="Node.js v8.9.0 文档"></a><a href="http://nodejs.cn/api/" title="Node.js v8.9.0 文档" target="_blank" rel="noopener">Node.js v8.9.0 文档</a></h6><blockquote>
<p>本文来源: <a href="http://www.zhufengpeixun.cn" title="珠峰培训" target="_blank" rel="noopener">珠峰培训</a></p>
<p>珠峰培训课程代码: <a href="https://github.com/zhufengnodejs/201601node" target="_blank" rel="noopener">https://github.com/zhufengnodejs/201601node</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/17/Node-js之事件-events/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/17/Node-js之事件-events/" itemprop="url">Node.js之事件_events</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-17T17:41:51+08:00">
                2017-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="events-事件"><a href="#events-事件" class="headerlink" title="events (事件)"></a>events (事件)</h1><p><a href="http://nodejs.cn/api/events.html" target="_blank" rel="noopener">http://nodejs.cn/api/events.html</a></p>
<h3 id="给监听器传入参数与-this"><a href="#给监听器传入参数与-this" class="headerlink" title="给监听器传入参数与 this"></a>给监听器传入参数与 <code>this</code></h3><p><code>eventEmitter.emit()</code> 方法允许将任意参数传给监听器函数。 当一个普通的监听器函数被 <code>EventEmitter</code> 调用时，标准的 <code>this</code> 关键词会被设置指向监听器所附加的 <code>EventEmitter</code></p>
<pre><code>const myEmitter = new MyEmitter();
myEmitter.on(&apos;event&apos;, function(a, b) {
  console.log(a, b, this);
  // 打印:
  //   a b MyEmitter {
  //     domain: null,
  //     _events: { event: [Function] },
  //     _eventsCount: 1,
  //     _maxListeners: undefined }
});
myEmitter.emit(&apos;event&apos;, &apos;a&apos;, &apos;b&apos;);
</code></pre><p>也可以使用 ES6 的箭头函数作为监听器。但是这样 this 关键词就不再指向 EventEmitter 实例：</p>
<pre><code>const myEmitter = new MyEmitter();
myEmitter.on(&apos;event&apos;, (a, b) =&gt; {
  console.log(a, b, this);
  // 打印: a b {}
});
myEmitter.emit(&apos;event&apos;, &apos;a&apos;, &apos;b&apos;);
</code></pre><h3 id="异步与同步"><a href="#异步与同步" class="headerlink" title="异步与同步"></a>异步与同步</h3><p><code>EventListener</code> 会按照监听器注册的顺序同步地调用所有监听器。 所以需要确保事件的正确排序且避免竞争条件或逻辑错误。 监听器函数可以使用 <code>setImmediate()</code> 或 <code>process.nextTick()</code> 方法切换到异步操作模式：</p>
<pre><code>const myEmitter = new MyEmitter();
myEmitter.on(&apos;event&apos;, (a, b) =&gt; {
  setImmediate(() =&gt; {
    console.log(&apos;这个是异步发生的&apos;);
  });
});
myEmitter.emit(&apos;event&apos;, &apos;a&apos;, &apos;b&apos;);
</code></pre><h3 id="只处理事件一次"><a href="#只处理事件一次" class="headerlink" title="只处理事件一次"></a>只处理事件一次</h3><p>当使用 <code>eventEmitter.on()</code> 方法注册监听器时，监听器会在每次触发命名事件时被调用</p>
<pre><code>const myEmitter = new MyEmitter();
let m = 0;
myEmitter.on(&apos;event&apos;, () =&gt; {
  console.log(++m);
});
myEmitter.emit(&apos;event&apos;);
// 打印: 1
myEmitter.emit(&apos;event&apos;);
// 打印: 2
</code></pre><p>使用 <code>eventEmitter.once()</code> 方法时可以注册一个对于特定事件最多被调用一次的监听器。 当事件被触发时，监听器会被注销，然后再调用</p>
<pre><code>const myEmitter = new MyEmitter();
let m = 0;
myEmitter.once(&apos;event&apos;, () =&gt; {
  console.log(++m);
});
myEmitter.emit(&apos;event&apos;);
// 打印: 1
myEmitter.emit(&apos;event&apos;);
// 忽略
</code></pre><h3 id="错误事件"><a href="#错误事件" class="headerlink" title="错误事件"></a>错误事件</h3><p>当 <code>EventEmitter</code> 实例中发生错误时，会触发一个 <code>&#39;error&#39;</code> 事件。 这在 Node.js 中是特殊情况</p>
<p>如果 <code>EventEmitter</code> 没有为 <code>&#39;error&#39;</code> 事件注册至少一个监听器，则当 <code>&#39;error&#39;</code> 事件触发时，会抛出错误、打印堆栈跟踪、且退出 Node.js 进程</p>
<pre><code>const myEmitter = new MyEmitter();
myEmitter.emit(&apos;error&apos;, new Error(&apos;whoops!&apos;));
// 抛出错误，并使 Node.js 崩溃
</code></pre><p>为了防止 Node.js 进程崩溃，可以在 process 对象的 uncaughtException 事件上注册监听器，或使用 domain 模块。 （注意，<code>domain</code> 模块已被废弃。）</p>
<pre><code>const myEmitter = new MyEmitter();

process.on(&apos;uncaughtException&apos;, (err) =&gt; {
  console.error(&apos;有错误&apos;);
});

myEmitter.emit(&apos;error&apos;, new Error(&apos;whoops!&apos;));
// 打印: 有错误
</code></pre><p>作为最佳实践，应该始终为 <code>&#39;error&#39;</code> 事件注册监听器</p>
<pre><code>const myEmitter = new MyEmitter();
myEmitter.on(&apos;error&apos;, (err) =&gt; {
  console.error(&apos;有错误&apos;);
});
myEmitter.emit(&apos;error&apos;, new Error(&apos;whoops!&apos;));
// 打印: 有错误
</code></pre><h3 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h3><p><code>EventEmitter</code> 类由 <code>events</code> 模块定义和开放的：</p>
<pre><code>const EventEmitter = require(&apos;events&apos;);
</code></pre><p>当新的监听器被添加时，所有的 EventEmitter 会触发 <code>&#39;newListener&#39;</code> 事件；当移除已存在的监听器时，则触发 <code>&#39;removeListener&#39;</code></p>
<h3 id="‘newListener’-事件"><a href="#‘newListener’-事件" class="headerlink" title="‘newListener’ 事件"></a>‘newListener’ 事件</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code> 要监听的事件的名称</li>
<li><code>listener</code> <code>&lt;Function&gt;</code> 事件的句柄函数</li>
</ul>
<p><code>EventEmitter</code> 实例会在一个监听器被添加到其内部监听器数组之前触发自身的 ‘newListener’ 事件</p>
<p>事实上，在添加监听器之前触发事件有一个微妙但重要的副作用： 在’newListener’ 回调函数中, 一个监听器的名字如果和已有监听器名称相同, 则在被插入到EventEmitter实例的内部监听器数组时, 该监听器会被添加到其它同名监听器的前面</p>
<pre><code>const myEmitter = new MyEmitter();
// 只处理一次，所以不会无限循环
myEmitter.once(&apos;newListener&apos;, (event, listener) =&gt; {
  if (event === &apos;event&apos;) {
    // 在开头插入一个新的监听器
    myEmitter.on(&apos;event&apos;, () =&gt; {
      console.log(&apos;B&apos;);
    });
  }
});
myEmitter.on(&apos;event&apos;, () =&gt; {
  console.log(&apos;A&apos;);
});
myEmitter.emit(&apos;event&apos;);
// 打印:
//   B
//   A
</code></pre><h3 id="‘removeListener’-事件"><a href="#‘removeListener’-事件" class="headerlink" title="‘removeListener’ 事件"></a>‘removeListener’ 事件</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code> 事件名</li>
<li><code>listener</code> <code>&lt;Function&gt;</code> 事件句柄函数</li>
</ul>
<p><code>&#39;removeListener&#39;</code> 事件在 <code>listener</code> 被移除后触发</p>
<h3 id="EventEmitter-defaultMaxListeners"><a href="#EventEmitter-defaultMaxListeners" class="headerlink" title="EventEmitter.defaultMaxListeners"></a>EventEmitter.defaultMaxListeners</h3><p>每个事件默认可以注册最多 10 个监听器。 单个 <code>EventEmitter</code> 实例的限制可以使用 <code>emitter.setMaxListeners(n)</code> 方法改变。 所有 <code>EventEmitter</code> 实例的默认值可以使用 <code>EventEmitter.defaultMaxListeners</code> 属性改变。 如果这个值不是正数, 那将抛出 TypeError错误.</p>
<p>设置 <code>EventEmitter.defaultMaxListeners</code> 要谨慎，因为会影响所有 <code>EventEmitter</code> 实例，包括之前创建的。 因而，调用 <code>emitter.setMaxListeners(n)</code> 优先于 <code>EventEmitter.defaultMaxListeners</code></p>
<p>注意，这不是一个硬性限制。 EventEmitter 实例允许添加更多的监听器，但会向 stderr 输出跟踪警告，表明检测到一个可能的 EventEmitter 内存泄漏。 对于任何单个 EventEmitter 实例，emitter.getMaxListeners() 和 emitter.setMaxListeners() 方法可用于暂时地消除此警告：</p>
<pre><code>emitter.setMaxListeners(emitter.getMaxListeners() + 1);
emitter.once(&apos;event&apos;, () =&gt; {
  // 做些操作
  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));
});
</code></pre><h3 id="emitter-addListener-eventName-listener"><a href="#emitter-addListener-eventName-listener" class="headerlink" title="emitter.addListener(eventName, listener)"></a>emitter.addListener(eventName, listener)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code></li>
<li><code>listener</code> <code>&lt;Function&gt;</code></li>
</ul>
<p><code>emitter.on(eventName, listener)</code> 的别名</p>
<h3 id="emitter-emit-eventName-…args"><a href="#emitter-emit-eventName-…args" class="headerlink" title="emitter.emit(eventName[, …args])"></a>emitter.emit(eventName[, …args])</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code></li>
<li><code>...args</code> <code>&lt;any&gt;</code></li>
</ul>
<p>按监听器的注册顺序，同步地调用每个注册到名为 ·eventName· 事件的监听器，并传入提供的参数</p>
<p>如果事件有监听器，则返回 <code>true</code> ，否则返回 <code>false</code></p>
<h3 id="emitter-eventNames"><a href="#emitter-eventNames" class="headerlink" title="emitter.eventNames()"></a>emitter.eventNames()</h3><p>返回一个列出触发器已注册监听器的事件的数组。 数组中的值为字符串或符号</p>
<pre><code>const EventEmitter = require(&apos;events&apos;);
const myEE = new EventEmitter();
myEE.on(&apos;foo&apos;, () =&gt; {});
myEE.on(&apos;bar&apos;, () =&gt; {});

const sym = Symbol(&apos;symbol&apos;);
myEE.on(sym, () =&gt; {});

console.log(myEE.eventNames());
// 打印: [ &apos;foo&apos;, &apos;bar&apos;, Symbol(symbol) ]
</code></pre><h3 id="emitter-getMaxListeners"><a href="#emitter-getMaxListeners" class="headerlink" title="emitter.getMaxListeners()"></a>emitter.getMaxListeners()</h3><p>返回 <code>EventEmitter</code> 当前的最大监听器限制值，该值可以通过 <code>emitter.setMaxListeners(n)</code> 设置或默认为 <code>EventEmitter.defaultMaxListeners</code></p>
<h3 id="emitter-listenerCount-eventName"><a href="#emitter-listenerCount-eventName" class="headerlink" title="emitter.listenerCount(eventName)"></a>emitter.listenerCount(eventName)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code> 正在被监听的事件名</li>
</ul>
<p>返回正在监听名为 <code>eventName</code> 的事件的监听器的数量</p>
<h3 id="emitter-listeners-eventName"><a href="#emitter-listeners-eventName" class="headerlink" title="emitter.listeners(eventName)"></a>emitter.listeners(eventName)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code></li>
</ul>
<p>返回名为 <code>eventName</code> 的事件的监听器数组的副本</p>
<pre><code>server.on(&apos;connection&apos;, (stream) =&gt; {
  console.log(&apos;someone connected!&apos;);
});
console.log(util.inspect(server.listeners(&apos;connection&apos;)));
// 打印: [ [Function] ]
</code></pre><h3 id="emitter-on-eventName-listener"><a href="#emitter-on-eventName-listener" class="headerlink" title="emitter.on(eventName, listener)"></a>emitter.on(eventName, listener)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code> 事件名</li>
<li><code>listener</code> <code>&lt;Function&gt;</code> 回调函数</li>
</ul>
<p>添加 <code>listener</code> 函数到名为 <code>eventName</code> 的事件的监听器数组的末尾。 不会检查 <code>listener</code> 是否已被添加。 多次调用并传入相同的 <code>eventName</code> 和 <code>listener</code> 会导致 <code>listener</code> 被添加与调用多次</p>
<pre><code>server.on(&apos;connection&apos;, (stream) =&gt; {
  console.log(&apos;有连接！&apos;);
});
</code></pre><p>返回一个 <code>EventEmitter</code> 引用，可以链式调用</p>
<p>默认情况下，事件监听器会按照添加的顺序依次调用。 <code>emitter.prependListener()</code> 方法可用于将事件监听器添加到监听器数组的开头</p>
<pre><code>const myEE = new EventEmitter();
myEE.on(&apos;foo&apos;, () =&gt; console.log(&apos;a&apos;));
myEE.prependListener(&apos;foo&apos;, () =&gt; console.log(&apos;b&apos;));
myEE.emit(&apos;foo&apos;);
// 打印:
//   b
//   a
</code></pre><h3 id="emitter-once-eventName-listener"><a href="#emitter-once-eventName-listener" class="headerlink" title="emitter.once(eventName, listener)"></a>emitter.once(eventName, listener)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code> 事件名</li>
<li><code>listener</code> <code>&lt;Function&gt;</code> 回调函数</li>
</ul>
<p>添加一个单次 <code>listener</code> 函数到名为 <code>eventName</code> 的事件。 下次触发 <code>eventName</code> 事件时，监听器会被移除，然后调用</p>
<pre><code>server.once(&apos;connection&apos;, (stream) =&gt; {
  console.log(&apos;首次调用！&apos;);
});
</code></pre><p>返回一个 <code>EventEmitter</code> 引用，可以链式调用</p>
<p>默认情况下，事件监听器会按照添加的顺序依次调用。 <code>emitter.prependOnceListener()</code> 方法可用于将事件监听器添加到监听器数组的开头</p>
<pre><code>const myEE = new EventEmitter();
myEE.once(&apos;foo&apos;, () =&gt; console.log(&apos;a&apos;));
myEE.prependOnceListener(&apos;foo&apos;, () =&gt; console.log(&apos;b&apos;));
myEE.emit(&apos;foo&apos;);
// 打印:
//   b
//   a
</code></pre><h3 id="emitter-prependListener-eventName-listener"><a href="#emitter-prependListener-eventName-listener" class="headerlink" title="emitter.prependListener(eventName, listener)"></a>emitter.prependListener(eventName, listener)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code> 事件名</li>
<li><code>listener</code> <code>&lt;Function&gt;</code> 回调函数</li>
</ul>
<p>添加 <code>listener</code> 函数到名为 <code>eventName</code> 的事件的监听器数组的开头。 不会检查 <code>listener</code> 是否已被添加。 多次调用并传入相同的 <code>eventName</code> 和 <code>listener</code> 会导致 <code>listener</code> 被添加与调用多次</p>
<pre><code>server.prependListener(&apos;connection&apos;, (stream) =&gt; {
  console.log(&apos;有连接！&apos;);
});
</code></pre><p>返回一个 <code>EventEmitter</code> 引用，可以链式调用</p>
<h3 id="emitter-prependOnceListener-eventName-listener"><a href="#emitter-prependOnceListener-eventName-listener" class="headerlink" title="emitter.prependOnceListener(eventName, listener)"></a>emitter.prependOnceListener(eventName, listener)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code> 事件名</li>
<li><p><code>listener</code> <code>&lt;Function&gt;</code> 回调函数<br>添加一个单次 <code>listener</code> 函数到名为 <code>eventName</code> 的事件的监听器数组的开头。 下次触发 <code>eventName</code> 事件时，监听器会被移除，然后调用</p>
<pre><code>server.prependOnceListener(&apos;connection&apos;, (stream) =&gt; {
  console.log(&apos;首次调用！&apos;);
});
</code></pre></li>
</ul>
<p>返回一个 <code>EventEmitter</code> 引用，可以链式调用</p>
<h3 id="emitter-removeAllListeners-eventName"><a href="#emitter-removeAllListeners-eventName" class="headerlink" title="emitter.removeAllListeners([eventName])"></a>emitter.removeAllListeners([eventName])</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code></li>
</ul>
<p>移除全部或指定 eventName 的监听器</p>
<p>注意，在代码中移除其他地方添加的监听器是一个不好的做法，尤其是当 EventEmitter 实例是其他组件或模块（如 socket 或文件流）创建的</p>
<p>返回一个 EventEmitter 引用，可以链式调用</p>
<h3 id="emitter-removeListener-eventName-listener"><a href="#emitter-removeListener-eventName-listener" class="headerlink" title="emitter.removeListener(eventName, listener)"></a>emitter.removeListener(eventName, listener)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code></li>
<li><code>listener</code> <code>&lt;Function&gt;</code></li>
</ul>
<p>从名为 eventName 的事件的监听器数组中移除指定的 listener</p>
<pre><code>const callback = (stream) =&gt; {
  console.log(&apos;有连接！&apos;);
};
server.on(&apos;connection&apos;, callback);
// ...
server.removeListener(&apos;connection&apos;, callback);
</code></pre><p><code>removeListener</code> 最多只会从监听器数组里移除一个监听器实例。 如果任何单一的监听器被多次添加到指定 <code>eventName</code> 的监听器数组中，则必须多次调用 <code>removeListener</code> 才能移除每个实例</p>
<p>注意，一旦一个事件被触发，所有绑定到它的监听器都会按顺序依次触发。 这意味着，在事件触发后、最后一个监听器完成执行前，任何 <code>removeListener()</code> 或 <code>removeAllListeners()</code> 调用都不会从 <code>emit()</code> 中移除它们。 随后的事件会像预期的那样发生</p>
<pre><code>const myEmitter = new MyEmitter();

const callbackA = () =&gt; {
  console.log(&apos;A&apos;);
  myEmitter.removeListener(&apos;event&apos;, callbackB);
};

const callbackB = () =&gt; {
  console.log(&apos;B&apos;);
};

myEmitter.on(&apos;event&apos;, callbackA);

myEmitter.on(&apos;event&apos;, callbackB);

// callbackA 移除了监听器 callbackB，但它依然会被调用。
// 触发是内部的监听器数组为 [callbackA, callbackB]
myEmitter.emit(&apos;event&apos;);
// 打印:
//   A
//   B

// callbackB 被移除了。
// 内部监听器数组为 [callbackA]
myEmitter.emit(&apos;event&apos;);
// 打印:
//   A
</code></pre><p>因为监听器是使用内部数组进行管理的，所以调用它会改变在监听器被移除后注册的任何监听器的位置索引。 虽然这不会影响监听器的调用顺序，但意味着由 <code>emitter.listeners()</code> 方法返回的监听器数组副本需要被重新创建</p>
<p>返回一个 <code>EventEmitter</code> 引用，可以链式调用</p>
<h3 id="emitter-setMaxListeners-n"><a href="#emitter-setMaxListeners-n" class="headerlink" title="emitter.setMaxListeners(n)"></a>emitter.setMaxListeners(n)</h3><ul>
<li><code>n</code> <code>&lt;integer&gt;</code></li>
</ul>
<p>默认情况下，如果为特定事件添加了超过 10 个监听器，则 <code>EventEmitter</code> 会打印一个警告。 此限制有助于寻找内存泄露。 但是，并不是所有的事件都要被限为 10 个。 <code>emitter.setMaxListeners()</code> 方法允许修改指定的 <code>EventEmitter</code> 实例的限制。 值设为 Infinity（或 0）表明不限制监听器的数量</p>
<p>返回一个 <code>EventEmitter</code> 引用，可以链式调用</p>
<h3 id="个人经验"><a href="#个人经验" class="headerlink" title="个人经验"></a>个人经验</h3><ul>
<li><p>通过查看 events 模块的源码发现 on 方法和 addListener 方法是同一个方法，没有任何区别</p>
<pre><code>EventEmitter.prototype.on = EventEmitter.prototype.addListener;
</code></pre></li>
<li><p><code>bind</code> 方法的使用</p>
<pre><code>function say(name,word) {
    console.log(name,word);
}
var newSay1 = say.bind(null);
var newSay2 = say.bind(null,&quot;张三&quot;);
newSay1(); // undefined undefined
newSay1(&quot;李四&quot;); // 李四 undefined
newSay1(&quot;李四&quot;,&quot;world&quot;); // 李四 world
// newSay2(); // 张三 undefined
newSay2(&quot;world&quot;); // 张三 world
</code></pre></li>
<li><p>模拟 <code>bind</code> 方法的实现</p>
<pre><code>function say(name,word){
    console.log(this.name,name,word);
}
var obj = {name:&apos;zfpx&apos;};
Function.prototype.bind = function(obj){
  var self = this;
    var args = Array.prototype.slice.call(arguments,1);
  return function(){
      var params = Array.prototype.slice.call(arguments);
      self.apply(obj,args.concat(params));
  }
}
var newSay = say.bind(obj,&apos;hello&apos;);

newSay(&apos;world&apos;);
</code></pre></li>
<li><p>模拟 <code>EventEmitter</code> 类的实现</p>
<pre><code>function EventEmitter(){
  this._events = {};//初始化一个私有的属性
}
//type 绑定的事件名
// listen 事件发生后的监听
EventEmitter.prototype.on = EventEmitter.prototype.addListener= function(type,listener){
   if(this._events[type]){
       this._events[type].push(listener);
   }else{
       this._events[type] = [listener];
   }
}
EventEmitter.prototype.emit = function(type){
    if(this._events[type])
        this._events[type].forEach(function(listener){
            listener();
        });
}
EventEmitter.prototype.removeListener=function(type,listener){
    if(this._events[type]){
        var listeners =  this._events[type];
        for(var i=0;i&lt;listeners.length;i++){
            if(listeners[i] === listener){
                listeners.splice(i,1);
                return;
            }
        }
    }

}
module.exports  = EventEmitter;
</code></pre></li>
</ul>
<h6 id="Node-js-v8-9-0-文档"><a href="#Node-js-v8-9-0-文档" class="headerlink" title="Node.js v8.9.0 文档"></a><a href="http://nodejs.cn/api/" title="Node.js v8.9.0 文档" target="_blank" rel="noopener">Node.js v8.9.0 文档</a></h6><blockquote>
<p>本文来源: <a href="http://www.zhufengpeixun.cn" title="珠峰培训" target="_blank" rel="noopener">珠峰培训</a></p>
<p>珠峰培训课程代码: <a href="https://github.com/zhufengnodejs/201601node" target="_blank" rel="noopener">https://github.com/zhufengnodejs/201601node</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/17/Node-js之全局对象-global/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/17/Node-js之全局对象-global/" itemprop="url">Node.js之全局对象_global</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-17T10:59:34+08:00">
                2017-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h1><ul>
<li>1.global的属性可以不用引用，也不用声明，就可以直接用</li>
<li>2.在node中在模块中能直接用有两种<ol>
<li>是全局对象下面的属性</li>
<li>初始化模块时传入的参数</li>
</ol>
</li>
<li><p>为什么能够直接在模块中访问 global,那是因为 global 也是 blobal 的属性(这句话比较绕口，但这确实是原理：自己身上有一个对自己的引用)</p>
</li>
<li><p>console</p>
<ul>
<li>console.log()</li>
<li>console.info()</li>
<li>console.error()</li>
<li>console.warn()</li>
<li>console.time()</li>
<li><p>console.timeEnd()</p>
<ul>
<li>需要传入一个字符串参数，并且要求两个方法的参数一致</li>
<li><p>用来计算在这两行代码之间的js代码执行所花费的时间，可以用来测试代码性能，对一些耗时间的代码进行针对性的优化</p>
<pre><code>console.time(&quot;test&quot;);
for (var i = 0; i &lt; 1000000; i++) {
}
console.timeEnd(&quot;test&quot;);
</code></pre></li>
</ul>
</li>
<li>日志重定向：可以把日志信息存储到一个文件中，方便日后寻找错误</li>
<li>在cmd命令窗口中通过cmd的特性使用日志重定向功能能够把log和info的输出重定向到日志文件中，如果需要把错误的日志信息也重定向到日志文件中，需要在前面加上”2”，当然普通的就是加”1”；那么就需要这样写：<code>node console.js1&gt;log.txt 2&gt;err.txt</code></li>
<li>如果还想把错误的日志信息也存放到普通的日志信息一起时，就需要这样写：<code>node console.js 1&gt;log.txt 2&gt;&amp;1</code></li>
</ul>
</li>
<li>__filename<ul>
<li>global.__filename-&gt;当前js文件的绝对路径以及文件名</li>
</ul>
</li>
<li>__dirname<ul>
<li>global.__dirname-&gt;当前js文件的绝对路径</li>
<li>这里注意 <strong>filename 和 </strong>dirname 都不是 global 的属性(试想一下，全局属性只能有一份，这样的话这两个属性值模块之间就会相互覆盖了，所以这是不存在的)，而是初始化模块时传入的参数(<strong>filename 和 </strong>dirname 是每个模块特有的)</li>
</ul>
</li>
<li>setTimeout(callback, delay[, …args])<ul>
<li>定时器(一次性执行)</li>
</ul>
</li>
<li>setImmediate(callback[, …args])<ul>
<li><code>callback</code> <code>&lt;Function&gt;</code> 在 Node.js 事件循环的当前回合结束时要调用的函数</li>
<li><code>...args</code> <code>&lt;any&gt;</code> 当调用 <code>callback</code> 时要传入的可选参数</li>
<li>返回一个用于 clearImmediate() 的 <code>Immediate</code></li>
<li>setImmediate 和 setTimeout 都是下一次执行的，但是它们谁先执行谁后执行存在几率，就是说不一定谁在前谁在后</li>
</ul>
</li>
</ul>
<h1 id="process"><a href="#process" class="headerlink" title="process"></a>process</h1><p><a href="http://www.css88.com/archives/4548" target="_blank" rel="noopener">http://www.css88.com/archives/4548</a></p>
<h3 id="process常用的方法"><a href="#process常用的方法" class="headerlink" title="process常用的方法"></a>process常用的方法</h3><ul>
<li>process.exit()：退出当前进程</li>
<li>process.stdout()-&gt;standard output</li>
<li>process.stderr()-&gt;standard error<ul>
<li>上面两个方法也是输出功能，其实console的相关输出功能就是调用了这两个方法（不管是为了减少代码的书写还是为了程序的可读性，推荐使用console对象进行输出）</li>
</ul>
</li>
<li><p>process.stdin()</p>
<ul>
<li>监听用户的输入（在监听之前需要进行编码的设置，注意这里的编码设置和之前网页内容的编码设置不同，一般这里设为”utf-8”，设为”gbk”或”gb2312”会报错）</li>
<li><p>然后通过”on”方法进行事件监听来监听用户的输入(有两种方法来获取用户的输入内容)</p>
<pre><code>process.stdin.setEncoding(&quot;utf-8&quot;);
//    process.stdin.on(&quot;data&quot;, function (data) {
//        console.log(data);
//    });
//另一种监听输入的方法：这个事件不会主动把用户的输入传到回调函数中，而需要手动的通过方法来获取
process.stdin.on(&quot;readable&quot;, function () {
    var data = process.stdin.read();
    console.log(data);
});
</code></pre></li>
</ul>
</li>
<li><p>process.cwd()</p>
<ul>
<li><p>cwd-&gt;current working dir;很容易和__dirname搞混(返回运行当前脚本的工作目录的路径)</p>
<pre><code>console.log(&quot;dirname:&quot; + __dirname);//dirname-&gt;js文件所在目录
console.log(&quot;cwd:&quot; + process.cwd());//cwd()-&gt;执行node命令时，我们在哪个目录
//例如cwd_subdir.js在subdir文件夹中，进入subdir的上一级目录，当在cmd窗口中这样执行时效果非常明显:node subdir/cwd_subdir.js
//dirname-&gt;js文件所在目录(就会到subdir这个目录)
//cwd()-&gt;执行node命令时，我们在哪个目录(这里就会是subdir的上一级目录)
</code></pre></li>
</ul>
</li>
<li>process.chdir()<ul>
<li>方法变更Node.js进程的当前工作目录，如果变更目录失败会抛出异常(例如，如果指定的目录不存在)(改变工作目录)</li>
</ul>
</li>
<li>process.memoryUsage()<ul>
<li>返回Node.js进程的内存使用情况的对象，该对象每个属性值的单位为字节</li>
</ul>
</li>
<li><p>process.nextTick()</p>
<ul>
<li>将 callback 添加到”next tick 队列”。 一旦当前事件轮询队列的任务全部完成，在next tick队列中的所有callbacks会被依次调用(将一个回调函数放在下次事件循环的顶部)</li>
<li><p>这种方式不是 <code>setTimeout(fn, 0)</code> 的别名。它更加有效率。事件轮询随后的ticks 调用，会在任何I/O事件（包括定时器）之前运行</p>
<pre><code>console.log(&apos;start&apos;);
process.nextTick(() =&gt; {
  console.log(&apos;nextTick callback&apos;);
});
console.log(&apos;scheduled&apos;);
// Output:
// start
// scheduled
// nextTick callback
</code></pre></li>
</ul>
</li>
</ul>
<h3 id="process常用的事件"><a href="#process常用的事件" class="headerlink" title="process常用的事件"></a>process常用的事件</h3><ul>
<li>“exit”-&gt;程序正常的退出触发执行</li>
<li><p>“SIGINT”(signal interrupted)-&gt;程序运行时出现一个中断信号触发执行</p>
<pre><code>//process事件：
process.on(&quot;exit&quot;, function () {
    console.log(&quot;programe will exit.&quot;);
});//在程序正常退出前执行
process.on(&quot;SIGINT&quot;, function () {
    console.log(&quot;programe has a sigint.&quot;);//（这里可以在用户按下&quot;ctrl+c&quot;强制退出前做一些必要的操作，然后再执行下面的方法退出）
    process.exit();//在处理中断的回调函数中让程序正常退出
});//例如之前监听用户输入时按下&quot;ctrl+c&quot;结束监听时就会产生一个中断信号
</code></pre></li>
</ul>
<h3 id="process常用的属性"><a href="#process常用的属性" class="headerlink" title="process常用的属性"></a>process常用的属性</h3><ul>
<li>process.argv<ul>
<li>返回一个数组，这个数组包含了启动Node.js进程时的命令行参数(当前进程的命令行参数数组)<ul>
<li>是一个数组，里面的内容是执行node命令时一条命令中以空格隔开的各项内容；其中第一项是node命令，第二项是执行的js文件的绝对路径；因此也就能通过这个属性来获取当执行node命令时在后面附加的其他参数（由于第0,1项都被占用了，所以其实是从第2项开始的）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="Node-js-v8-9-0-文档"><a href="#Node-js-v8-9-0-文档" class="headerlink" title="Node.js v8.9.0 文档"></a><a href="http://nodejs.cn/api/" title="Node.js v8.9.0 文档" target="_blank" rel="noopener">Node.js v8.9.0 文档</a></h6><blockquote>
<p>本文来源: <a href="http://www.zhufengpeixun.cn" title="珠峰培训" target="_blank" rel="noopener">珠峰培训</a></p>
<p>珠峰培训课程代码: <a href="https://github.com/zhufengnodejs/201601node" target="_blank" rel="noopener">https://github.com/zhufengnodejs/201601node</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/14/Node-js之ajax/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/14/Node-js之ajax/" itemprop="url">Node.js之ajax</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-14T21:38:53+08:00">
                2017-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一步-创建-ajax-对象"><a href="#第一步-创建-ajax-对象" class="headerlink" title="第一步    创建 ajax 对象"></a>第一步    <strong>创建</strong> <code>ajax</code> 对象</h1><p><code>var XHR = new XMLHttpRequest();</code></p>
<h1 id="第二步-打开请求"><a href="#第二步-打开请求" class="headerlink" title="第二步    打开请求"></a>第二步    <strong>打开</strong>请求</h1><p><code>xhr.open(method, url, async, user, password);</code></p>
<h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><p><img src="/img/open.png" alt="open.png" title="open.png"></p>
<h1 id="第三步-指定接收响应的-回调函数"><a href="#第三步-指定接收响应的-回调函数" class="headerlink" title="第三步    指定接收响应的 回调函数"></a>第三步    指定接收响应的 回调函数</h1><ul>
<li><p>当 XMLHTTPRequest 对象的 <code>readyState</code> 属性改变时调用回调函数</p>
<p>  <code>xhr.onreadystatechange = function(){};</code></p>
</li>
</ul>
<h1 id="XHR-对象状态"><a href="#XHR-对象状态" class="headerlink" title="XHR 对象状态"></a>XHR 对象状态</h1><p><img src="/img/readyState1.png" alt="readyState1.png" title="readyState1.png"></p>
<h1 id="readyState-状态的值"><a href="#readyState-状态的值" class="headerlink" title="readyState 状态的值"></a><code>readyState</code> 状态的<strong>值</strong></h1><p><img src="/img/readyState2.png" alt="readyState2.png" title="readyState2.png"></p>
<h1 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h1><p><img src="/img/response.png" alt="response.png" title="response.png"></p>
<h1 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h1><ul>
<li><code>send</code> 方法会把参数放到<strong>请求体</strong>里</li>
<li>所有 <code>get</code> 不能通过请求体传<strong>参数</strong>，而 <code>post</code> 可以</li>
<li><p>当使用同步的时候，<code>send</code> 方法后都会阻塞，一直等到服务器响应，所以 <code>send</code> 方法要放到<strong>最后</strong></p>
<p>  <code>xhr.send(varBody);</code></p>
</li>
</ul>
<h3 id="send-方法重载参数"><a href="#send-方法重载参数" class="headerlink" title="send 方法重载参数"></a><code>send</code> 方法重载参数</h3><p><img src="/img/send.png" alt="send.png" title="send.png"></p>
<h1 id="form-标签的-enctype-属性"><a href="#form-标签的-enctype-属性" class="headerlink" title="form 标签的 enctype 属性"></a><code>form</code> 标签的 <code>enctype</code> 属性</h1><p><img src="/img/form_enctype.png" alt="form_enctype.png" title="form_enctype.png"></p>
<h1 id="xhr-对象的方法"><a href="#xhr-对象的方法" class="headerlink" title="xhr 对象的方法"></a><code>xhr</code> 对象的<strong>方法</strong></h1><p><img src="/img/xhr_function.png" alt="xhr_function.png" title="xhr_function.png"></p>
<h1 id="xhr-对象的属性"><a href="#xhr-对象的属性" class="headerlink" title="xhr 对象的属性"></a><code>xhr</code> 对象的<strong>属性</strong></h1><p><img src="/img/xhr_attr.png" alt="xhr_attr.png" title="xhr_attr.png"></p>
<h1 id="responseType-响应类型"><a href="#responseType-响应类型" class="headerlink" title="responseType 响应类型"></a><code>responseType</code> 响应类型</h1><ul>
<li><code>XMLHttpRequest.responseType</code> 设置该值能够改变响应类型，设置后会把 <code>XMLHttpRequest.response</code> 转化为相应的类型<br><img src="/img/responseType.png" alt="responseType.png" title="responseType.png"></li>
</ul>
<h1 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h1><p>文件上传、预览、删除等功能: <a href="http://blog.csdn.net/qingyjl/article/details/52003567" target="_blank" rel="noopener">http://blog.csdn.net/qingyjl/article/details/52003567</a></p>
<ul>
<li><p>上传图片需要使用 <code>type=&quot;file&quot;</code> 类型的 <code>input</code> 元素</p>
<p>  <code>&lt;input type=&quot;file&quot; multiple  name=&quot;avatar&quot;&gt;</code></p>
<p>  其中 <code>multiple</code> 属性是用来上传多张图片的， <code>name</code> 属性可以自定义</p>
</li>
<li>把上传后的图片显示出来<ol>
<li>在服务器端，把 files 里的 avatar 里的path读出来，根据此路径通过 <code>fs.readFile</code> 方法把图片复制到 imgs 目录下</li>
<li>把此图片的路径返回浏览器端</li>
<li>在浏览器端构建一个 img 元素，追加到 body 上，并且指定 img 的 src 属性，此处 src 属性值为服务器返回的图片路径</li>
<li>服务器端可以接收客户端发出的请求图片的请求，服务器返回图片的内容，最终在浏览器端图片得到显示</li>
</ol>
</li>
</ul>
<h1 id="FormData-对象-H5-新对象-的使用"><a href="#FormData-对象-H5-新对象-的使用" class="headerlink" title="FormData 对象(H5 新对象)的使用"></a><code>FormData</code> 对象(H5 新对象)的使用</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects</a></p>
<p><a href="https://www.cnblogs.com/lhb25/p/html5-formdata-tutorials.html" target="_blank" rel="noopener">https://www.cnblogs.com/lhb25/p/html5-formdata-tutorials.html</a></p>
<h3 id="通过FormData对象可以组装一组用-XMLHttpRequest发送请求的键-值对。它可以更灵活方便的发送表单数据，因为可以独立于表单使用。如果你把表单的编码类型设置为multipart-form-data-，则通过FormData传输的数据格式和表单通过submit-方法传输的数据格式相同"><a href="#通过FormData对象可以组装一组用-XMLHttpRequest发送请求的键-值对。它可以更灵活方便的发送表单数据，因为可以独立于表单使用。如果你把表单的编码类型设置为multipart-form-data-，则通过FormData传输的数据格式和表单通过submit-方法传输的数据格式相同" class="headerlink" title="通过FormData对象可以组装一组用 XMLHttpRequest发送请求的键/值对。它可以更灵活方便的发送表单数据，因为可以独立于表单使用。如果你把表单的编码类型设置为multipart/form-data ，则通过FormData传输的数据格式和表单通过submit() 方法传输的数据格式相同"></a>通过FormData对象可以组装一组用 XMLHttpRequest发送请求的键/值对。它可以更灵活方便的发送表单数据，因为可以独立于表单使用。如果你把表单的编码类型设置为multipart/form-data ，则通过FormData传输的数据格式和表单通过submit() 方法传输的数据格式相同</h3><pre><code>//准备发送给服务器的数据
var formData = new FormData();
//给这个表单对象增加一个表单元素
formData.append(&apos;username&apos;,document.querySelector(&apos;input[name=username]&apos;).value);
//给这个表单对象增加一个表单元素
formData.append(&apos;password&apos;,document.querySelector(&apos;input[name=password]&apos;).value);
var avatar = document.querySelector(&apos;input[name=avatar]&apos;)
//给这个表单对象增加一个文件元素
formData.append(&apos;avatar&apos;,avatar.files[0]);
xhr.send(formData);
</code></pre><h1 id="formidable-模块"><a href="#formidable-模块" class="headerlink" title="formidable 模块"></a><code>formidable</code> 模块</h1><p><a href="http://blog.csdn.net/charlene0824/article/details/51234394" target="_blank" rel="noopener">http://blog.csdn.net/charlene0824/article/details/51234394</a></p>
<pre><code>if (pathname == &apos;/reg2&apos;) {
    // 构建一个解析器
    var formParser = new formidable.IncomingForm();
    ///用解析器解析请求体
    //非file的input会放在fields里
    //文件类型的元素会放在files里(文件这么分类都是 parse 方法自动处理的)
    formParser.parse(req, function (err, fields, files) {
        fs.readFile(files.avatar.path, function (err, data) {
            console.log(files.avatar);
            var filename = &apos;/imgs/&apos; + files.avatar.name; // 创建存放图片的目录
            fs.writeFile(&apos;.&apos; + filename, data, function (err) { // 根据此路径通过 fs.readFile 方法复制图片
                res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});
                res.end(filename); // 把此图片的路径返回浏览器端
            })
        })
    });
}

// files
{ avatar: 
   File {
     domain: null,
     _events: {},
     _eventsCount: 0,
     _maxListeners: undefined,
     size: 42271,
     path: &apos;C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\upload_11b9e023ed180f1f0cb33f5a23fae377&apos;,
     name: &apos;boy.png&apos;,
     type: &apos;image/png&apos;,
     hash: null,
     lastModifiedDate: 2017-12-15T04:11:11.380Z,
     _writeStream: 
      WriteStream {
        _writableState: [Object],
        writable: false,
        domain: null,
        _events: {},
        _eventsCount: 0,
        _maxListeners: undefined,
        path: &apos;C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\upload_11b9e023ed180f1f0cb33f5a23fae377&apos;,
        fd: null,
        flags: &apos;w&apos;,
        mode: 438,
        start: undefined,
        autoClose: true,
        pos: undefined,
        bytesWritten: 42271,
        closed: true 
      } 
    } 
}
</code></pre><h1 id="querystring-模块"><a href="#querystring-模块" class="headerlink" title="querystring 模块"></a><code>querystring</code> 模块</h1><p><a href="http://yijiebuyi.com/blog/d37512fc6df0fc4d0adfc2ec5c3d46ff.html" target="_blank" rel="noopener">http://yijiebuyi.com/blog/d37512fc6df0fc4d0adfc2ec5c3d46ff.html</a></p>
<h3 id="node-js原生自带，直接-require-‘querystring’-即可使用"><a href="#node-js原生自带，直接-require-‘querystring’-即可使用" class="headerlink" title="node.js原生自带，直接 require(‘querystring’) 即可使用"></a>node.js原生自带，直接 require(‘querystring’) 即可使用</h3><ul>
<li><p>querystring.parse(str, [sep], [eq], [options])</p>
<p>  参数字符串(查询字符串)格式化成对象</p>
<pre><code>var obj={name:&quot;一介布衣&quot;,url:&quot;http://yijiebuyi.com&quot;};
var param= querystring.stringify(obj);
</code></pre><p>  我们把param 字符串格式化成对象,使用默认分隔分配符</p>
<pre><code>var newobj=querystring.parse(param);
console.log(typeof newobj,newobj);
</code></pre><p>  打印出来格式化后的数据类型 和 内容<br><img src="/img/querystring_parse1.png" alt="querystring_parse1.png" title="querystring_parse1.png"></p>
<p>  可以看到格式化以后是object类型,并且汉字自动解码显示出来.<br>  当覆盖分割和分配符,如下:</p>
<pre><code>param=querystring.stringify(obj,&apos;|&apos;,&apos;*&apos;);
console.log(param);
</code></pre><p><img src="/img/querystring_parse2.png" alt="querystring_parse2.png" title="querystring_parse2.png"></p>
</li>
<li><p>querystring.stringify(obj, [sep], [eq])</p>
<p>  对象格式化成参数字符串 ,obj就是要格式化的对象,必选参数</p>
<pre><code>var obj={name:&quot;一介布衣&quot;,url:&quot;http://yijiebuyi.com&quot;};
var param= querystring.stringify(obj);
//没有指定分隔符和分配符,并且自动编码汉字
console.log(param);
</code></pre><p><img src="/img/querystring_stringify1.png" alt="querystring_stringify1.png" title="querystring_stringify1.png"></p>
<pre><code>param=querystring.stringify(obj,&apos;|&apos;,&apos;*&apos;);
//指定了分隔符和分配符
console.log(param);
</code></pre><p><img src="/img/querystring_stringify2.png" alt="querystring_stringify2.png" title="querystring_stringify2.png"></p>
</li>
</ul>
<h1 id="util-模块"><a href="#util-模块" class="headerlink" title="util 模块"></a><code>util</code> 模块</h1><p><a href="http://www.runoob.com/nodejs/nodejs-util.html" target="_blank" rel="noopener">http://www.runoob.com/nodejs/nodejs-util.html</a></p>
<ul>
<li>util.inspect(object,[showHidden],[depth],[colors])<br>  util.inspect 是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出；它至少接受一个参数 object，即要转换的对象<ul>
<li>showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息</li>
<li>depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少；如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象</li>
<li>如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果<blockquote>
<p>特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>代码示例：</p>
<pre><code>var util = require(&apos;util&apos;); 
function Person() { 
    this.name = &apos;byvoid&apos;; 
    this.toString = function() { 
    return this.name; 
    }; 
} 
var obj = new Person(); 
console.log(util.inspect(obj)); 
console.log(util.inspect(obj, true));
</code></pre><p>运行结果是：</p>
<pre><code>Person { name: &apos;byvoid&apos;, toString: [Function] }
Person {
  name: &apos;byvoid&apos;,
  toString: 
   { [Function]
     [length]: 0,
     [name]: &apos;&apos;,
     [arguments]: null,
     [caller]: null,
     [prototype]: { [constructor]: [Circular] } } }
</code></pre><ul>
<li>util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数</li>
</ul>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf</a></p>
<ul>
<li><p>示例如下：</p>
<pre><code>var util = require(&apos;util&apos;); 
function Base() { 
    this.name = &apos;base&apos;; 
    this.base = 1991; 
    this.sayHello = function() { 
    console.log(&apos;Hello &apos; + this.name); 
    }; 
} 
Base.prototype.showName = function() { 
    console.log(this.name);
}; 
function Sub() { 
    this.name = &apos;sub&apos;; 
} 
util.inherits(Sub, Base); 
var objBase = new Base(); 
objBase.showName(); 
objBase.sayHello(); 
console.log(objBase); 
var objSub = new Sub(); 
objSub.showName(); 
//objSub.sayHello(); 
console.log(objSub); 
</code></pre></li>
<li><p>我们定义了一个基础对象Base 和一个继承自Base 的Sub，Base 有三个在构造函数 内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承。运行结果如下：</p>
<pre><code>base 
Hello base 
{ name: &apos;base&apos;, base: 1991, sayHello: [Function] } 
sub 
{ name: &apos;sub&apos; }
</code></pre></li>
<li><p>注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。<br>同时，在原型中定义的属性不会被console.log 作 为对象的属性输出。如果我们去掉 objSub.sayHello(); 这行的注释，将会看到：</p>
<pre><code>node.js:201 
throw e; // process.nextTick error, or &apos;error&apos; event on first tick 
^ 
TypeError: Object #&amp;lt;Sub&amp;gt; has no method &apos;sayHello&apos; 
</code></pre></li>
<li><p>util.inherits(Children,Parent) <code>&lt;Child,Parent是两个类&gt;</code> 实现原理：<code>Object.setPrototypeOf(ctor.prototype,superCtor.prototype)-&gt; Children.prototype=new Parent();</code></p>
<pre><code>util.inherits(Children,Parent)
// 解释：
function temp() {}
temp.prototype=Parent.prototype;
Children.prototype=new temp();
</code></pre></li>
<li><p>通过 <code>Parent.call(this);</code> 实现子类对父类在非原型上的自定义的属性的继承</p>
<pre><code>function Children() {
    Parent.call(this);
    this.name = &quot;children&quot;;
}
</code></pre></li>
<li><p>util.isArray(object)</p>
<ul>
<li>如果给定的参数 “object” 是一个数组返回true，否则返回false</li>
</ul>
</li>
<li>util.isRegExp(object)<ul>
<li>如果给定的参数 “object” 是一个正则表达式返回true，否则返回false</li>
</ul>
</li>
<li>util.isDate(object)<ul>
<li>如果给定的参数 “object” 是一个日期返回true，否则返回false</li>
</ul>
</li>
<li>util.isError(object)<ul>
<li>如果给定的参数 “object” 是一个错误对象返回true，否则返回false</li>
</ul>
</li>
</ul>
<h1 id="mime-模块"><a href="#mime-模块" class="headerlink" title="mime 模块"></a><code>mime</code> 模块</h1><p><a href="https://www.cnblogs.com/jeacy/p/6992435.html" target="_blank" rel="noopener">https://www.cnblogs.com/jeacy/p/6992435.html</a></p>
<pre><code>// 在使用nodejs中的mime模块处理静态文件的时候，出现mime.lookup的错误，
// 具体错误如下：
// mime.lookup is not a function
// 原因是：mime 2.x.x 版本修改了函数名: lookup() -&gt; getType()
</code></pre><h1 id="url-模块"><a href="#url-模块" class="headerlink" title="url 模块"></a><code>url</code> 模块</h1><p><a href="http://blog.csdn.net/vanhukseter/article/details/43870271" target="_blank" rel="noopener">http://blog.csdn.net/vanhukseter/article/details/43870271</a></p>
<ul>
<li><p>url.parse(urlString,boolean,boolean)</p>
<p>  parse 这个方法可以将一个url的字符串解析并返回一个url的对象</p>
<p>  参数：urlString 指传入一个url地址的字符串</p>
</li>
</ul>
<p>　　　　　第二个参数（可省）传入一个布尔值，默认为false，为true时，返回的url对象中，query的属性为一个对象。</p>
<p>　　　　　第三个参数（可省）传入一个布尔值，默认为false，为true时，解析时会将url的”//”和第一个”/”之间的部分解析为主机名</p>
<p>示例:</p>
<pre><code>var url = require(&apos;url&apos;);
url.parse(&apos;http://www.baidu.com/news&apos;,false,true);
</code></pre><p>返回的结果：</p>
<pre><code>{ protocol: &apos;http:&apos;,
  slashes: true,
  auth: null,
  host: &apos;www.baidu.com&apos;,
  port: null,
  hostname: &apos;www.baidu.com&apos;,
  hash: null,
  search: null,
  query: null,
  pathname: &apos;/news&apos;,
  path: &apos;/news&apos;,
  href: &apos;http://www.baidu.com/news&apos; }
</code></pre><h1 id="request-的-data-事件"><a href="#request-的-data-事件" class="headerlink" title="request 的 data 事件"></a>request 的 <code>data</code> 事件</h1><p><a href="http://www.runoob.com/nodejs/node-js-get-post.html" target="_blank" rel="noopener">http://www.runoob.com/nodejs/node-js-get-post.html</a></p>
<pre><code>if(pathname == &apos;/reg&apos;){
    var result=&apos;&apos;;
    //当读到客户端提交过来的数据时会触发data事件，然后调用回调函数(通过req的data事件监听函数，每当接受到请求体的数据，就累加到result变量中)
    req.on(&apos;data&apos;,function(data){
        result +=data;
    })
    req.on(&apos;end&apos;,function(){
        // 数据接收完毕(在end事件触发后，通过querystring.parse将result解析为真正的POST请求格式，然后向客户端返回)
        result = querystring.parse(result);
        res.end(util.inspect(result)); // 发送响应
    })
}
</code></pre><h1 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h1><pre><code>/**
     *  . 当前目录
     *  ./index.js 当前目录下的某个文件
     *  / 1. 如果是在HTML的链接里，代表URL 根目录
     *    2. 如果出现在读文件的时候,则它代理当前盘符的根目录
     *  index.js 代表当前目录下面的index.js文件 == ./index.js
     *  .. 代表上一级目录
     *  ../../ 代表上一级的上一级目录
     */
</code></pre><h1 id="处理表单数据"><a href="#处理表单数据" class="headerlink" title="处理表单数据"></a>处理表单数据</h1><h3 id="处理成一个数组"><a href="#处理成一个数组" class="headerlink" title="处理成一个数组"></a>处理成一个数组</h3><pre><code>function serialize(form) {
    // 把表单中的元素集合转成一个数组
    var elements = Array.prototype.slice.call(form.elements);
    var data = [];
    // 循环这个数组
    elements.forEach(function (element) {
        //先取出元素的类型
        var type = element.type;
        switch (type) {
            case &apos;submit&apos;:
            case &apos;cancel&apos;:
            case &apos;reset&apos;:
                break;
            case &apos;text&apos;:
                data.push(element.name + &apos;=&apos; + element.value); // 把 type=&quot;text&quot; 的 input 元素添加至数组中，得到一个字符串数组
        }
    });
    // 通过 join 方法将该数组以 &apos;&amp;&apos; 为分割符转换为字符串并返回
    return data.join(&apos;&amp;&apos;);
}

// 把表单的数据 转成查询字符串
var data = serialize(document.querySelector(&apos;form&apos;));
// 把数据放在请求体里发送给服务器
xhr.send(data);
</code></pre><h3 id="处理成一个对象"><a href="#处理成一个对象" class="headerlink" title="处理成一个对象"></a>处理成一个对象</h3><pre><code>function toJson(form) {
    // 把表单中的元素集合转成一个 JSON 格式对象
    var elements = Array.prototype.slice.call(form.elements);
    var data = {};
    // 循环这个数组
    elements.forEach(function (element) {
        // 先取出元素的类型
        var type = element.type;
        switch (type) {
            case &apos;submit&apos;:
            case &apos;cancel&apos;:
            case &apos;reset&apos;:
                break;
            case &apos;text&apos;:
                data[element.name] = element.value; // 把 type=&quot;text&quot; 的 input 元素以 key-value 形式将表单元素的 name 和 value 添加至对象中
        }
    });
    // 返回该对象
    return data;
}

// 把表单的数据 转成 JSON 对象
var data = toJson(document.querySelector(&apos;form&apos;));
//把数据放在请求体里发送给服务器，注意不能直接把对象发送给服务器，需要转成字符串的形式
xhr.send(JSON.stringify(data));
</code></pre><h1 id="ajax-请求注意事项"><a href="#ajax-请求注意事项" class="headerlink" title="ajax 请求注意事项"></a><code>ajax</code> 请求注意事项</h1><ul>
<li>xhr.send() 方法不要错误的放到 onreadystatechange 对应的回调函数中去，那样不会发送请求(这个错误比较隐晦，不容易被发现)</li>
<li>异步请求时xhr.send() 是异步执行的方法，所以 onreadystatechange 方法可以放在 send 方法的前面和后面都可以；但是当为同步请求时，onreadystatechange 方法一定要放在 send 方法的前面，否则无法操作返回的数据</li>
<li>只有当提交form表单，并且是GET请求的时候，浏览器才会把表单进行序列化(参数字符串)拼到URL后面(因为GET请求没有请求体)</li>
<li>在 form 起始标签中可以通过 “method” 来指定是 “GET” 还是 “POST” 请求</li>
<li>只有 type=”submit” 的按钮在点击后才会生成查询字符串(参数字符串) -&gt; <input type="submit" value="注册">;<input type="button" id="regBtn" value="注册"> 这样是不会生成参数字符串的</li>
<li>POST 请求也不会生成参数字符串，因为 POST 请求会把它放到请求体里面</li>
<li>xhr.setRequestHeader(‘Content-Type’,’application/x-www-form-urlencoded’); //设置请求头，不同的数据格式要采用不同的数据编码方式，而且这里设置的编码方式要和下面 send 方法中传递的数据的格式一致；为什么要相同呢？ -&gt; 因为服务器就是通过 Content-Type 来确定客户端发送的数据格式的，从而进行相关的数据解析，如果不一致的话，服务器解析就会出错</li>
<li>在 form 表单中通过 enctype 属性来设置编码方式，当需要上传图片时，值为 “multipart/form-data”</li>
<li>我们通过 xhr.send() 发送请求数据是中间步骤，为什么要先写 xhr.responseType=”json”; xhr.onreadystatechange=function() {}; …获取响应信息的代码. 最后写 xhr.send();这其实和绑定点击事件是一个道理，先要给点击事件绑定相应的方法，然后再点击；如果已经点击了再绑定方法就没用了</li>
<li>使用 fs.exists(path, callback) 方法时，注意 path 如果是相对路径下的当前路径，记得要在路径前加上 “.”</li>
<li>服务器配置路由时最后应该要配置其他所有未明确指定路径应该访问的资源，这样就不会导致客户端访问已有资源时出错(而且在服务端，html 文件引入 js 文件的相对路径前可以添加任意多个 “../“，因为添加的这些貌似不会对服务器读取资源产生任何影响，如： ../../js/index.js 与 ../js/index.js 与 index.js 都是相同的效果；但是如果添加一些指定的不存在的路径时，比如： /test/js/index.js 就会请求资源出错；以上只针对于服务端，当在本地预览 html 页面时，还是应该正确书写引用文件路径，如： ../js/index.js)</li>
</ul>
<h1 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h1><ul>
<li><p>Fiddler</p>
<p>  目前最常用的http抓包工具之一</p>
</li>
</ul>
<h6 id="Node-js-v8-9-0-文档"><a href="#Node-js-v8-9-0-文档" class="headerlink" title="Node.js v8.9.0 文档"></a><a href="http://nodejs.cn/api/" title="Node.js v8.9.0 文档" target="_blank" rel="noopener">Node.js v8.9.0 文档</a></h6><blockquote>
<p>本文来源: <a href="http://www.zhufengpeixun.cn" title="珠峰培训" target="_blank" rel="noopener">珠峰培训</a></p>
<p>珠峰培训课程代码: <a href="https://github.com/zhufengnodejs/201601node" target="_blank" rel="noopener">https://github.com/zhufengnodejs/201601node</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/12/Node-js之http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/12/Node-js之http/" itemprop="url">Node.js之http</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-12T23:09:02+08:00">
                2017-12-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="命令行中执行"><a href="#命令行中执行" class="headerlink" title="命令行中执行"></a>命令行中执行</h1><ul>
<li>命令行窗口中： <code>netstat</code> 命令用于显示各种网络相关信息</li>
<li><p>也可以通过 git bash 命令行窗口来访问服务器</p>
<p>  输入命令： curl <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> / curl -v <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>  (可以是任意可访问的地址)</p>
<p>  可以看到请求和响应的内容</p>
<p>  User-Agent: 代表客户端的代理（每种浏览器的代理都不一样，服务器用这个来判断客户端类型），此时命令行中的代理就是 curl</p>
<p>  Accept: 代表可以接接收的结果类型(可以指定是接收html还是js，<em>/</em>代表任意)</p>
<p>  Transfer-Encoding: chunked -&gt; 传输的编码(chunked:分块传输)</p>
</li>
</ul>
<p><img src="/img/http_curl.png" alt="http_curl" title="http_curl.png"></p>
<ul>
<li>利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障；应用格式：Ping空格IP地址。该命令还可以加许多参数使用，具体是键入Ping按回车即可看到详细说明</li>
</ul>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><ul>
<li>服务器可以是<strong>专业</strong>服务器也可以是<strong>个人</strong>电脑</li>
<li>能在<strong>特定(IP)服务器</strong>的<strong>特定端口</strong>上监听客户端的请求，并根据请求的路径返回相应结果都叫服务器</li>
</ul>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><ul>
<li>只要能向<strong>特定(IP)服务器</strong>的<strong>特定端口</strong>发起请求并接受响应的都叫客户端</li>
</ul>
<h1 id="数据在服务器和客户端之间传递"><a href="#数据在服务器和客户端之间传递" class="headerlink" title="数据在服务器和客户端之间传递"></a>数据在服务器和客户端之间传递</h1><ul>
<li>可以把服务器硬盘上的<strong>已经有的静态文件</strong>发送给客户端</li>
<li>也可以由服务器经过逻辑处理生成的<strong>动态内容</strong>返回给客户端，比如<strong>当前时间</strong></li>
<li>一个 http 事务由一条(从客户端发往服务器的)请求命令和一个(从服务器发回客户端的)响应结果组成</li>
</ul>
<h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><ul>
<li>人与人之间通信，需要一种<strong>传输手段</strong>(声波)和一种彼此抖动的语言(比如普通话)</li>
<li>要让这些形形色色的机器能够通过网络进行交互，我们就需要指明一种<strong>协议</strong>(比如 HTTP/HTTPS)和一种<strong>数据封装格式</strong>(比如 HTML/JSON)</li>
<li>http 指的就是这种协议 + 数据格式的交流体系<br><img src="/img/http.png" alt="http" title="http.png"></li>
</ul>
<h1 id="一个普通网站访问的过程-1"><a href="#一个普通网站访问的过程-1" class="headerlink" title="一个普通网站访问的过程(1)"></a>一个普通网站访问的过程(1)</h1><h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程(1)"></a>过程(1)</h2><ul>
<li>浏览器(或其他客户端，如：微信)向服务器发起一个<strong>HTTP请求</strong></li>
<li>先把<strong>域名解析为IP地址</strong>(chrome 缓存1分钟(chrome://net-internals/#dns) -&gt; 搜索操作系统缓存 -&gt; 读取本地 host 文件 -&gt; 打气 DNS 系统调用 -&gt; 运营商 DNS 缓存 -&gt; 找根域 -&gt; com 域)</li>
<li>哭护短通过随机端口向服务器发起 TCP 三次握手，建立了 <strong>TCP 连接</strong></li>
<li>连接建立后浏览器就可以 <strong>发送HTTP请求</strong>了</li>
<li>服务器接收到 HTTP 请求，解析请求的路径和参数，经过后台的一些处理之后<strong>生成完整响应</strong>页面</li>
<li>服务器将生成的页面作为 HTTP 响应体，根据不同的处理结果生成 响应头，发回给客户端</li>
</ul>
<h2 id="过程-2"><a href="#过程-2" class="headerlink" title="过程(2)"></a>过程(2)</h2><ul>
<li>客户端(浏览器)接收到 HTTP 响应，从请求中得到的 HTTP 响应体里是 HTML 代码，于是对 HTML 代码开始解析</li>
<li>解析过程中遇到<strong>引用的服务器上的资源</strong>(额外的CSS、JS代码、图片、音视频、附件等等)，再向服务器发送请求</li>
<li>浏览器解析 HTML 包含的内容，用得到的 CSS 代码进行外观上的进一步<strong>渲染</strong>，JS 代码也可能会对外观进行一定的<strong>处理</strong></li>
<li>当客户与<strong>页面交互</strong>(点击、悬停等等)时，JS 代码对此作出一定的反应，添加特效与动画</li>
<li>交互的过程中可能需要向服务器索取或提交额外的数据(局部的刷新)，一般不是通过跳转就是通过 JS 代码(响应某个动作或者定时)向服务器发送<strong>AJAX</strong>请求</li>
<li>服务器再把客户端需要的资源返回，客户端用得到的资源来实现动态效果或者<strong>修改 DOM 结构</strong></li>
</ul>
<h1 id="请求的方式"><a href="#请求的方式" class="headerlink" title="请求的方式"></a>请求的方式</h1><ul>
<li><code>GET</code></li>
</ul>
<p>从服务器获取资源，比如请求一张空白的注册表单</p>
<ul>
<li><code>POST</code></li>
</ul>
<p>向服务器提交数据，比如提交注册表单</p>
<h1 id="请求的-URL"><a href="#请求的-URL" class="headerlink" title="请求的 URL"></a>请求的 <code>URL</code></h1><p><img src="/img/http_url.png" alt="http_url" title="http_url.png"></p>
<h1 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h1><ul>
<li>每条 http 请求报文都包括一个方法表示本次将要进行何种类型的操作，如入去一个页面，删除一个资源</li>
<li>GET 是用来从服务器获取数据，没有请求体，不会影响服务器端的数据</li>
<li>POST 是用来将数据发送到服务器，post 会把要发送的数据放到请求体中，可能会影响到服务器端的数据<br>简单说明:<br><img src="/img/http_method1.png" alt="http_method1" title="method_method1.png"><br>详细说明(来源于<a href="http://www.runoob.com/http/http-methods.html" title="菜鸟教程" target="_blank" rel="noopener">菜鸟教程</a>):<br><img src="/img/http_method2.png" alt="http_method2" title="method_method2.png"></li>
</ul>
<h1 id="常见请求头信息"><a href="#常见请求头信息" class="headerlink" title="常见请求头信息"></a>常见请求头信息</h1><h3 id="从客户端发往服务器发送请求报文所使用的字段，用于补充请求的附加信息"><a href="#从客户端发往服务器发送请求报文所使用的字段，用于补充请求的附加信息" class="headerlink" title="从客户端发往服务器发送请求报文所使用的字段，用于补充请求的附加信息"></a>从客户端发往服务器发送请求报文所使用的字段，用于补充请求的附加信息</h3><ul>
<li><p><code>host</code></p>
<p>  请求的服务主机；HTTP/1.1 请求必须包含主机头，否则会返回 <code>404</code> 状态码</p>
</li>
<li><p><code>connection</code></p>
<p>  客户端和服务器<strong>连接</strong>选项</p>
</li>
<li><p><code>accept</code></p>
<p>  告诉服务器客户端能够处理的<strong>内容类型</strong>和<strong>优先级</strong><br>  q=表示权重，用分号隔开<code>;</code>,范围是0-1，不指定时权重默认为1</p>
</li>
<li><p><code>user-agent</code></p>
<p>  <strong>用户代理</strong>，是指浏览器，它的信息包括硬件平台，系统软件，应用软件和用户个人偏好</p>
</li>
<li><p><code>accept-encoding</code></p>
<p>  告诉服务器哭护短支持的<strong>内容编码</strong>及内容编码的<strong>优先级</strong>顺序</p>
</li>
<li><p><code>accept-language</code></p>
<p>  告诉服务器能够处理的<strong>语言</strong>以及优先级</p>
</li>
</ul>
<h1 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h1><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p><img src="/img/http_message_request.png" alt="http_message_request" title="http_message_request.png"></p>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p><img src="/img/http_message_response.png" alt="http_message_response" title="http_message_response.png"></p>
<h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><ul>
<li>状态码是一个三单位数字的代码，告知响应结果的类型</li>
<li>伴随着每个数字状态码，http 还会发送一条解释性的原因短语文本</li>
</ul>
<h2 id="状态码类型"><a href="#状态码类型" class="headerlink" title="状态码类型"></a>状态码类型</h2><ul>
<li><p>1xx</p>
<p>  请求正在处理</p>
</li>
<li><p>2xx</p>
<p>  请求处理完成</p>
<ul>
<li><code>200 OK</code> 请求成功</li>
</ul>
</li>
<li><p>3xx</p>
<p>  重定向</p>
<ul>
<li><code>301 Moved Permanently</code> 永久重定向</li>
<li><code>302 Found</code> 临时重定向</li>
</ul>
</li>
<li><p>4xx</p>
<p>  客户端错误</p>
<ul>
<li><code>400 Bad request</code> 语法错误</li>
<li><code>401 Unauthorized</code> 权限未认证</li>
<li><code>403 Forbidden</code> 禁止访问</li>
<li><code>404 Not Found</code> 资源未找到</li>
</ul>
</li>
<li><p>5xx</p>
<p>  服务器端错误</p>
</li>
</ul>
<h1 id="MIME-媒体类型"><a href="#MIME-媒体类型" class="headerlink" title="MIME 媒体类型"></a>MIME 媒体类型</h1><ul>
<li>MIME 类型就是告诉浏览器用什么方式来处理这个数据</li>
<li>MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条杠来分隔，如 <code>text/html</code></li>
<li>MIME 类型在 HTTP 协议中表现为 Request Header 或者 Response Header 中的 <code>Content-Type</code><br><img src="/img/http_mime.png" alt="http_mime" title="http_mime.png"></li>
</ul>
<p>更多类型: <a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">http://tool.oschina.net/commons</a></p>
<h1 id="http-模块-http-模块主要用于搭建-HTTP-服务"><a href="#http-模块-http-模块主要用于搭建-HTTP-服务" class="headerlink" title="http 模块(http 模块主要用于搭建 HTTP 服务)"></a>http 模块(http 模块主要用于搭建 HTTP 服务)</h1><h2 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h2><ul>
<li><p>创建 HTTP 服务并<strong>动态响应</strong>当前时间</p>
<p>  <code>server.listen(port,[host],[backlog],[callback])</code></p>
<ul>
<li><code>port</code> 端口</li>
<li><code>host</code>    主机</li>
<li><code>backlog</code>    <strong>等待</strong>中的队列数量，默认值是 511</li>
<li><code>callback</code> server(服务)监听成功(<strong>请求</strong>到来)的时候服务器调用的回调函数</li>
</ul>
</li>
</ul>
<p><img src="/img/http_createServer.png" alt="http_createServer" title="http_createServer.png"></p>
<ul>
<li><p>将上面这几行代码保存成 app.js，然后用 node 调用这个文件，服务器就开始运行了</p>
<p>  <code>$ node app.js</code></p>
</li>
<li><p>命令行窗口将显示一行提示: “Server running on port 8080.”<br>打开浏览器，访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 网页显示: 2015-12-23 18:07:00</p>
</li>
</ul>
<blockquote>
<p>当通过 webstorm 开启了一个服务(server)之后，没有关闭服务就退出了，这时就没有 Terminal 那个红色方块的停止按钮了，但是可以通过在 任务管理器 的进程中输入 ‘n’来找到 node.exe 进程，右键”结束进程”即可</p>
</blockquote>
<h2 id="响应头信息"><a href="#响应头信息" class="headerlink" title="响应头信息"></a>响应头信息</h2><p><code>response.writeHead(statusCode,[reasonPhrase],[headers])</code></p>
<ul>
<li><p><code>statusCode</code></p>
<p>  <strong>状态码</strong></p>
</li>
<li><p><code>reasonPhrase</code></p>
<p>  状态码<strong>描述</strong>信息</p>
</li>
<li><p><code>headers</code></p>
<p>  响应头对象</p>
<ul>
<li>content-type <strong>内容类型</strong>    </li>
<li>location <strong>重定向</strong>到的URL地址</li>
<li>content-disposition    下载的<strong>文件名</strong></li>
<li>content-length 响应内容的<strong>字节数</strong></li>
<li>set-cookie 写入客户端<strong>cookie</strong></li>
<li>content-encoding 响应内容的<strong>编码</strong>方式</li>
<li>Cache-Control <strong>缓存</strong></li>
<li>Expires 指定缓存<strong>过期时间</strong></li>
<li>Etag 服务器响应<strong>内容没有发生变化</strong>时不重新下载数据</li>
<li>connection 默认是 <code>keep-alive</code> <strong>保持连接</strong>，想断开连接用 <code>close</code></li>
</ul>
</li>
</ul>
<h2 id="设置响应头"><a href="#设置响应头" class="headerlink" title="设置响应头"></a>设置响应头</h2><ul>
<li><p><code>setHeader</code> 方法可以单独设置响应头</p>
<pre><code>response,setHeader(name,value);
</code></pre></li>
<li><p>如果多个响应头的话可以使用数组</p>
<pre><code>response,setHeader(&quot;Set-cookie&quot;,[&quot;name=newlife&quot;,&quot;age=23&quot;]);
</code></pre></li>
</ul>
<h2 id="其他响应设置"><a href="#其他响应设置" class="headerlink" title="其他响应设置"></a>其他响应设置</h2><ul>
<li><code>getHeader</code> <strong>获取</strong>响应头</li>
<li><code>removeHeader</code> <strong>移除</strong>响应头</li>
<li><code>headerSent</code> 响应头是否<strong>已经发送</strong></li>
<li><code>sendData</code> 是否发送<em>响应时间**</em></li>
<li><code>statusCode</code> 设置<strong>响应码</strong></li>
</ul>
<h2 id="使用-url-模块处理-url"><a href="#使用-url-模块处理-url" class="headerlink" title="使用 url 模块处理 url"></a>使用 <code>url</code> 模块处理 <code>url</code></h2><p><code>var url = require(&quot;url&quot;);</code><br><code>var urlObj = url.parse(&quot;原始的url&quot;);</code></p>
<p><code>urlObj</code> 的属性</p>
<ul>
<li><p>href</p>
<p>  被转换的<strong>原URL</strong>字符串</p>
</li>
<li><p>protocal</p>
<p>  客户端请求时的<strong>协议</strong></p>
</li>
<li><p>slashes</p>
<p>  在协议与路径中间是否使用<strong>//</strong>分隔符</p>
</li>
<li><p>host</p>
<p>  字符串中完整的<strong>地址及端口号</strong>，可能为IP也可能为主机名</p>
</li>
<li><p>auth</p>
<p>  <strong>认证</strong>部分</p>
</li>
<li><p>hostname</p>
<p>  <strong>主机名或IP</strong></p>
</li>
<li><p>port</p>
<p>  <strong>端口</strong>号</p>
</li>
<li><p>pathname</p>
<p>  <strong>路径</strong>不包含查询字符串</p>
</li>
<li><p>query</p>
<p>  不包含起始字符<code>?</code>的<strong>查询字符串</strong>，或根据该查询字符串转换而成的对象(由 parse 方法的第二个参数决定，true 就会转成对象)</p>
<pre><code>var url = require(&quot;url&quot;);
var str = &quot;http://192.168.155.1:80/index.html?name=zhufeng&amp;age=7#bbs&quot;;
console.log(url.parse(str));

/*
 Url {
 protocol: &apos;http:&apos;,传输协议
 slashes: true,
 auth: null,
 host: &apos;192.168.155.1:80&apos;,域名+端口号
 port: null,端口号
 hostname: &apos;192.168.155.1&apos;,域名(IP)
 hash: &apos;#bbs&apos;,哈希值
 search: &apos;?name=zhufeng&amp;age=7&apos;,?+传递进来的数据
 query: &apos;name=zhufeng&amp;age=7&apos;,传递进来的数据（不加？）
 pathname: &apos;/index.html&apos;,请求文件的路径及名称
 path: &apos;/index.html?name=zhufeng&amp;age=7&apos;,路径名称+传递的数据
 href: &apos;http://192.168.155.1/index.html?name=zhufeng&amp;age=7&apos; 初始地址（包含所有）
 }
 */

console.log(url.parse(str, true));//增加true后，query中存储的是经过处理解析后的结果：把传递进来的多组数据以键值对的方式进行存储
/*
 ...
 query: {name：&apos;zhufeng&apos;，age：&apos;7&apos;},
 ...
 **/
</code></pre></li>
</ul>
<h2 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h2><p><code>querystring</code> 用来对查询字符串进行转换</p>
<pre><code>var queryObj = querystring.parse(str,[sep],[eq],[options]); //字符串转对象
var queryStr = querystring.stringify(obj,[sep],[eq]); //对象转字符串
</code></pre><ul>
<li><p><code>str</code></p>
<p>  需要被转换的<strong>查询字符串</strong></p>
</li>
<li><p><code>sep</code></p>
<p>  查询字符串中的<strong>分隔</strong>字符，默认为 <code>&amp;</code></p>
</li>
<li><p><code>eq</code></p>
<p>  查询字符串中的<strong>分配</strong>字符，默认参数为 <code>=</code></p>
</li>
<li><p><code>options</code></p>
<p>  为对象参数，可以指定 maxKeys 属性指明转换后的<strong>属性个数</strong>，0 为不限定</p>
</li>
</ul>
<h2 id="写入请求并发送请求"><a href="#写入请求并发送请求" class="headerlink" title="写入请求并发送请求"></a>写入请求并发送请求</h2><ul>
<li><p><code>write</code> 方法向目标服务器<strong>发送数据</strong>，write 方法可以多次调用</p>
<pre><code>request.write(chunk,[encoding]);
</code></pre><ul>
<li><p>chunk 要发送的<strong>数据</strong>，可以是 <code>Buffer</code> 或 字符串</p>
<blockquote>
<ul>
<li><p>response.write(66);</p>
<p>  会报错： first must be a string or Buffer(只能是这两种，其他的都不行)</p>
</li>
<li><p>在响应头发出以后不能再发送响应头</p>
</li>
</ul>
</blockquote>
</li>
<li>encoding <strong>编码</strong>，不指定时默认是 <code>utf8</code></li>
</ul>
</li>
<li><p><code>end</code> 方法用来<strong>结束</strong>本次请求</p>
<pre><code>request.end(chunk,[encoding]);
</code></pre></li>
</ul>
<h2 id="读取静态资源文件并返回"><a href="#读取静态资源文件并返回" class="headerlink" title="读取静态资源文件并返回"></a>读取静态资源文件并返回</h2><p><img src="/img/http_file.png" alt="http_file" title="http_file.png"></p>
<h2 id="根据不同的请求进行不同的响应-路由"><a href="#根据不同的请求进行不同的响应-路由" class="headerlink" title="根据不同的请求进行不同的响应(路由)"></a>根据不同的请求进行不同的响应(路由)</h2><p><img src="/img/http_router.png" alt="http_router" title="http_router.png"></p>
<h2 id="处理-POST-请求"><a href="#处理-POST-请求" class="headerlink" title="处理 POST 请求"></a>处理 <code>POST</code> 请求</h2><ul>
<li>当客户端采用 POST 发送数据时，服务器端可以监听<code>request</code>对象的<code>data</code>和<code>end</code>两个事件<br><img src="/img/http_post.png" alt="http_post" title="http_post.png"></li>
<li><code>data</code>事件会在数据接收过程中，<strong>每收到一段数据</strong>就触发一次，接收到的数据被传入回调函数</li>
<li><code>end</code>事件则是在<strong>所有数据</strong>接收完成后触发</li>
</ul>
<h1 id="创建-http-客户端"><a href="#创建-http-客户端" class="headerlink" title="创建 http 客户端"></a>创建 http 客户端</h1><p><code>request</code> 方法可以向其他网站请求数据</p>
<ul>
<li><p>options</p>
<ul>
<li><p>host </p>
<p>  <strong>域名</strong>或目标主机IP</p>
</li>
<li><p>hostname </p>
<p>  <strong>域名</strong>或目标主机，优先级比 host 高</p>
</li>
<li><p>port </p>
<p>  <strong>端口</strong>号</p>
</li>
<li><p>method </p>
<p>  请求<strong>方法</strong></p>
</li>
<li><p>path</p>
<p>  请求的<strong>路径</strong>，默认为 <code>/</code></p>
</li>
<li><p>headers</p>
<p>  客户端请求<strong>头对象</strong></p>
</li>
<li><p>auth</p>
<p>  <strong>认证</strong>信息，如 “username:password”</p>
</li>
</ul>
</li>
<li>callback = function(response) {}<br>当<strong>获取</strong>到目标网站所返回的<strong>响应流</strong>时调用的回调函数<ul>
<li><code>response</code> 是一个 http.IncomingMessage 对象，可以从中 <code>读</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>方法说明及示例：<br><a href="https://www.cnblogs.com/liyinghao/p/6180591.html" target="_blank" rel="noopener">https://www.cnblogs.com/liyinghao/p/6180591.html</a></p>
</blockquote>
<p>引用说明</p>
<blockquote>
<p>本文资料来源于<strong>珠峰培训</strong><br>链接: <a href="http://www.zhufengpeixun.cn" target="_blank" rel="noopener">http://www.zhufengpeixun.cn</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="newlife" />
            
              <p class="site-author-name" itemprop="name">newlife</p>
              <p class="site-description motion-element" itemprop="description">newlife means newborn</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/newlife201702" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:1245204973@qq.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">newlife</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
