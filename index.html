<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="newlife means newborn">
<meta property="og:type" content="website">
<meta property="og:title" content="newlife&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="newlife&#39;s blog">
<meta property="og:description" content="newlife means newborn">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="newlife&#39;s blog">
<meta name="twitter:description" content="newlife means newborn">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>newlife's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">newlife's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/17/Node-js之事件-events/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/17/Node-js之事件-events/" itemprop="url">Node.js之事件_events</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-17T17:41:51+08:00">
                2017-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="events-事件"><a href="#events-事件" class="headerlink" title="events (事件)"></a>events (事件)</h1><p><a href="http://nodejs.cn/api/events.html" target="_blank" rel="noopener">http://nodejs.cn/api/events.html</a></p>
<h3 id="给监听器传入参数与-this"><a href="#给监听器传入参数与-this" class="headerlink" title="给监听器传入参数与 this"></a>给监听器传入参数与 <code>this</code></h3><p><code>eventEmitter.emit()</code> 方法允许将任意参数传给监听器函数。 当一个普通的监听器函数被 <code>EventEmitter</code> 调用时，标准的 <code>this</code> 关键词会被设置指向监听器所附加的 <code>EventEmitter</code></p>
<pre><code>const myEmitter = new MyEmitter();
myEmitter.on(&apos;event&apos;, function(a, b) {
  console.log(a, b, this);
  // 打印:
  //   a b MyEmitter {
  //     domain: null,
  //     _events: { event: [Function] },
  //     _eventsCount: 1,
  //     _maxListeners: undefined }
});
myEmitter.emit(&apos;event&apos;, &apos;a&apos;, &apos;b&apos;);
</code></pre><p>也可以使用 ES6 的箭头函数作为监听器。但是这样 this 关键词就不再指向 EventEmitter 实例：</p>
<pre><code>const myEmitter = new MyEmitter();
myEmitter.on(&apos;event&apos;, (a, b) =&gt; {
  console.log(a, b, this);
  // 打印: a b {}
});
myEmitter.emit(&apos;event&apos;, &apos;a&apos;, &apos;b&apos;);
</code></pre><h3 id="异步与同步"><a href="#异步与同步" class="headerlink" title="异步与同步"></a>异步与同步</h3><p><code>EventListener</code> 会按照监听器注册的顺序同步地调用所有监听器。 所以需要确保事件的正确排序且避免竞争条件或逻辑错误。 监听器函数可以使用 <code>setImmediate()</code> 或 <code>process.nextTick()</code> 方法切换到异步操作模式：</p>
<pre><code>const myEmitter = new MyEmitter();
myEmitter.on(&apos;event&apos;, (a, b) =&gt; {
  setImmediate(() =&gt; {
    console.log(&apos;这个是异步发生的&apos;);
  });
});
myEmitter.emit(&apos;event&apos;, &apos;a&apos;, &apos;b&apos;);
</code></pre><h3 id="只处理事件一次"><a href="#只处理事件一次" class="headerlink" title="只处理事件一次"></a>只处理事件一次</h3><p>当使用 <code>eventEmitter.on()</code> 方法注册监听器时，监听器会在每次触发命名事件时被调用</p>
<pre><code>const myEmitter = new MyEmitter();
let m = 0;
myEmitter.on(&apos;event&apos;, () =&gt; {
  console.log(++m);
});
myEmitter.emit(&apos;event&apos;);
// 打印: 1
myEmitter.emit(&apos;event&apos;);
// 打印: 2
</code></pre><p>使用 <code>eventEmitter.once()</code> 方法时可以注册一个对于特定事件最多被调用一次的监听器。 当事件被触发时，监听器会被注销，然后再调用</p>
<pre><code>const myEmitter = new MyEmitter();
let m = 0;
myEmitter.once(&apos;event&apos;, () =&gt; {
  console.log(++m);
});
myEmitter.emit(&apos;event&apos;);
// 打印: 1
myEmitter.emit(&apos;event&apos;);
// 忽略
</code></pre><h3 id="错误事件"><a href="#错误事件" class="headerlink" title="错误事件"></a>错误事件</h3><p>当 <code>EventEmitter</code> 实例中发生错误时，会触发一个 <code>&#39;error&#39;</code> 事件。 这在 Node.js 中是特殊情况</p>
<p>如果 <code>EventEmitter</code> 没有为 <code>&#39;error&#39;</code> 事件注册至少一个监听器，则当 <code>&#39;error&#39;</code> 事件触发时，会抛出错误、打印堆栈跟踪、且退出 Node.js 进程</p>
<pre><code>const myEmitter = new MyEmitter();
myEmitter.emit(&apos;error&apos;, new Error(&apos;whoops!&apos;));
// 抛出错误，并使 Node.js 崩溃
</code></pre><p>为了防止 Node.js 进程崩溃，可以在 process 对象的 uncaughtException 事件上注册监听器，或使用 domain 模块。 （注意，<code>domain</code> 模块已被废弃。）</p>
<pre><code>const myEmitter = new MyEmitter();

process.on(&apos;uncaughtException&apos;, (err) =&gt; {
  console.error(&apos;有错误&apos;);
});

myEmitter.emit(&apos;error&apos;, new Error(&apos;whoops!&apos;));
// 打印: 有错误
</code></pre><p>作为最佳实践，应该始终为 <code>&#39;error&#39;</code> 事件注册监听器</p>
<pre><code>const myEmitter = new MyEmitter();
myEmitter.on(&apos;error&apos;, (err) =&gt; {
  console.error(&apos;有错误&apos;);
});
myEmitter.emit(&apos;error&apos;, new Error(&apos;whoops!&apos;));
// 打印: 有错误
</code></pre><h3 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h3><p><code>EventEmitter</code> 类由 <code>events</code> 模块定义和开放的：</p>
<pre><code>const EventEmitter = require(&apos;events&apos;);
</code></pre><p>当新的监听器被添加时，所有的 EventEmitter 会触发 <code>&#39;newListener&#39;</code> 事件；当移除已存在的监听器时，则触发 <code>&#39;removeListener&#39;</code></p>
<h3 id="‘newListener’-事件"><a href="#‘newListener’-事件" class="headerlink" title="‘newListener’ 事件"></a>‘newListener’ 事件</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code> 要监听的事件的名称</li>
<li><code>listener</code> <code>&lt;Function&gt;</code> 事件的句柄函数</li>
</ul>
<p><code>EventEmitter</code> 实例会在一个监听器被添加到其内部监听器数组之前触发自身的 ‘newListener’ 事件</p>
<p>事实上，在添加监听器之前触发事件有一个微妙但重要的副作用： 在’newListener’ 回调函数中, 一个监听器的名字如果和已有监听器名称相同, 则在被插入到EventEmitter实例的内部监听器数组时, 该监听器会被添加到其它同名监听器的前面</p>
<pre><code>const myEmitter = new MyEmitter();
// 只处理一次，所以不会无限循环
myEmitter.once(&apos;newListener&apos;, (event, listener) =&gt; {
  if (event === &apos;event&apos;) {
    // 在开头插入一个新的监听器
    myEmitter.on(&apos;event&apos;, () =&gt; {
      console.log(&apos;B&apos;);
    });
  }
});
myEmitter.on(&apos;event&apos;, () =&gt; {
  console.log(&apos;A&apos;);
});
myEmitter.emit(&apos;event&apos;);
// 打印:
//   B
//   A
</code></pre><h3 id="‘removeListener’-事件"><a href="#‘removeListener’-事件" class="headerlink" title="‘removeListener’ 事件"></a>‘removeListener’ 事件</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code> 事件名</li>
<li><code>listener</code> <code>&lt;Function&gt;</code> 事件句柄函数</li>
</ul>
<p><code>&#39;removeListener&#39;</code> 事件在 <code>listener</code> 被移除后触发</p>
<h3 id="EventEmitter-defaultMaxListeners"><a href="#EventEmitter-defaultMaxListeners" class="headerlink" title="EventEmitter.defaultMaxListeners"></a>EventEmitter.defaultMaxListeners</h3><p>每个事件默认可以注册最多 10 个监听器。 单个 <code>EventEmitter</code> 实例的限制可以使用 <code>emitter.setMaxListeners(n)</code> 方法改变。 所有 <code>EventEmitter</code> 实例的默认值可以使用 <code>EventEmitter.defaultMaxListeners</code> 属性改变。 如果这个值不是正数, 那将抛出 TypeError错误.</p>
<p>设置 <code>EventEmitter.defaultMaxListeners</code> 要谨慎，因为会影响所有 <code>EventEmitter</code> 实例，包括之前创建的。 因而，调用 <code>emitter.setMaxListeners(n)</code> 优先于 <code>EventEmitter.defaultMaxListeners</code></p>
<p>注意，这不是一个硬性限制。 EventEmitter 实例允许添加更多的监听器，但会向 stderr 输出跟踪警告，表明检测到一个可能的 EventEmitter 内存泄漏。 对于任何单个 EventEmitter 实例，emitter.getMaxListeners() 和 emitter.setMaxListeners() 方法可用于暂时地消除此警告：</p>
<pre><code>emitter.setMaxListeners(emitter.getMaxListeners() + 1);
emitter.once(&apos;event&apos;, () =&gt; {
  // 做些操作
  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));
});
</code></pre><h3 id="emitter-addListener-eventName-listener"><a href="#emitter-addListener-eventName-listener" class="headerlink" title="emitter.addListener(eventName, listener)"></a>emitter.addListener(eventName, listener)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code></li>
<li><code>listener</code> <code>&lt;Function&gt;</code></li>
</ul>
<p><code>emitter.on(eventName, listener)</code> 的别名</p>
<h3 id="emitter-emit-eventName-…args"><a href="#emitter-emit-eventName-…args" class="headerlink" title="emitter.emit(eventName[, …args])"></a>emitter.emit(eventName[, …args])</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code></li>
<li><code>...args</code> <code>&lt;any&gt;</code></li>
</ul>
<p>按监听器的注册顺序，同步地调用每个注册到名为 ·eventName· 事件的监听器，并传入提供的参数</p>
<p>如果事件有监听器，则返回 <code>true</code> ，否则返回 <code>false</code></p>
<h3 id="emitter-eventNames"><a href="#emitter-eventNames" class="headerlink" title="emitter.eventNames()"></a>emitter.eventNames()</h3><p>返回一个列出触发器已注册监听器的事件的数组。 数组中的值为字符串或符号</p>
<pre><code>const EventEmitter = require(&apos;events&apos;);
const myEE = new EventEmitter();
myEE.on(&apos;foo&apos;, () =&gt; {});
myEE.on(&apos;bar&apos;, () =&gt; {});

const sym = Symbol(&apos;symbol&apos;);
myEE.on(sym, () =&gt; {});

console.log(myEE.eventNames());
// 打印: [ &apos;foo&apos;, &apos;bar&apos;, Symbol(symbol) ]
</code></pre><h3 id="emitter-getMaxListeners"><a href="#emitter-getMaxListeners" class="headerlink" title="emitter.getMaxListeners()"></a>emitter.getMaxListeners()</h3><p>返回 <code>EventEmitter</code> 当前的最大监听器限制值，该值可以通过 <code>emitter.setMaxListeners(n)</code> 设置或默认为 <code>EventEmitter.defaultMaxListeners</code></p>
<h3 id="emitter-listenerCount-eventName"><a href="#emitter-listenerCount-eventName" class="headerlink" title="emitter.listenerCount(eventName)"></a>emitter.listenerCount(eventName)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code> 正在被监听的事件名</li>
</ul>
<p>返回正在监听名为 <code>eventName</code> 的事件的监听器的数量</p>
<h3 id="emitter-listeners-eventName"><a href="#emitter-listeners-eventName" class="headerlink" title="emitter.listeners(eventName)"></a>emitter.listeners(eventName)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code></li>
</ul>
<p>返回名为 <code>eventName</code> 的事件的监听器数组的副本</p>
<pre><code>server.on(&apos;connection&apos;, (stream) =&gt; {
  console.log(&apos;someone connected!&apos;);
});
console.log(util.inspect(server.listeners(&apos;connection&apos;)));
// 打印: [ [Function] ]
</code></pre><h3 id="emitter-on-eventName-listener"><a href="#emitter-on-eventName-listener" class="headerlink" title="emitter.on(eventName, listener)"></a>emitter.on(eventName, listener)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code> 事件名</li>
<li><code>listener</code> <code>&lt;Function&gt;</code> 回调函数</li>
</ul>
<p>添加 <code>listener</code> 函数到名为 <code>eventName</code> 的事件的监听器数组的末尾。 不会检查 <code>listener</code> 是否已被添加。 多次调用并传入相同的 <code>eventName</code> 和 <code>listener</code> 会导致 <code>listener</code> 被添加与调用多次</p>
<pre><code>server.on(&apos;connection&apos;, (stream) =&gt; {
  console.log(&apos;有连接！&apos;);
});
</code></pre><p>返回一个 <code>EventEmitter</code> 引用，可以链式调用</p>
<p>默认情况下，事件监听器会按照添加的顺序依次调用。 <code>emitter.prependListener()</code> 方法可用于将事件监听器添加到监听器数组的开头</p>
<pre><code>const myEE = new EventEmitter();
myEE.on(&apos;foo&apos;, () =&gt; console.log(&apos;a&apos;));
myEE.prependListener(&apos;foo&apos;, () =&gt; console.log(&apos;b&apos;));
myEE.emit(&apos;foo&apos;);
// 打印:
//   b
//   a
</code></pre><h3 id="emitter-once-eventName-listener"><a href="#emitter-once-eventName-listener" class="headerlink" title="emitter.once(eventName, listener)"></a>emitter.once(eventName, listener)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code> 事件名</li>
<li><code>listener</code> <code>&lt;Function&gt;</code> 回调函数</li>
</ul>
<p>添加一个单次 <code>listener</code> 函数到名为 <code>eventName</code> 的事件。 下次触发 <code>eventName</code> 事件时，监听器会被移除，然后调用</p>
<pre><code>server.once(&apos;connection&apos;, (stream) =&gt; {
  console.log(&apos;首次调用！&apos;);
});
</code></pre><p>返回一个 <code>EventEmitter</code> 引用，可以链式调用</p>
<p>默认情况下，事件监听器会按照添加的顺序依次调用。 <code>emitter.prependOnceListener()</code> 方法可用于将事件监听器添加到监听器数组的开头</p>
<pre><code>const myEE = new EventEmitter();
myEE.once(&apos;foo&apos;, () =&gt; console.log(&apos;a&apos;));
myEE.prependOnceListener(&apos;foo&apos;, () =&gt; console.log(&apos;b&apos;));
myEE.emit(&apos;foo&apos;);
// 打印:
//   b
//   a
</code></pre><h3 id="emitter-prependListener-eventName-listener"><a href="#emitter-prependListener-eventName-listener" class="headerlink" title="emitter.prependListener(eventName, listener)"></a>emitter.prependListener(eventName, listener)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code> 事件名</li>
<li><code>listener</code> <code>&lt;Function&gt;</code> 回调函数</li>
</ul>
<p>添加 <code>listener</code> 函数到名为 <code>eventName</code> 的事件的监听器数组的开头。 不会检查 <code>listener</code> 是否已被添加。 多次调用并传入相同的 <code>eventName</code> 和 <code>listener</code> 会导致 <code>listener</code> 被添加与调用多次</p>
<pre><code>server.prependListener(&apos;connection&apos;, (stream) =&gt; {
  console.log(&apos;有连接！&apos;);
});
</code></pre><p>返回一个 <code>EventEmitter</code> 引用，可以链式调用</p>
<h3 id="emitter-prependOnceListener-eventName-listener"><a href="#emitter-prependOnceListener-eventName-listener" class="headerlink" title="emitter.prependOnceListener(eventName, listener)"></a>emitter.prependOnceListener(eventName, listener)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code> 事件名</li>
<li><p><code>listener</code> <code>&lt;Function&gt;</code> 回调函数<br>添加一个单次 <code>listener</code> 函数到名为 <code>eventName</code> 的事件的监听器数组的开头。 下次触发 <code>eventName</code> 事件时，监听器会被移除，然后调用</p>
<pre><code>server.prependOnceListener(&apos;connection&apos;, (stream) =&gt; {
  console.log(&apos;首次调用！&apos;);
});
</code></pre></li>
</ul>
<p>返回一个 <code>EventEmitter</code> 引用，可以链式调用</p>
<h3 id="emitter-removeAllListeners-eventName"><a href="#emitter-removeAllListeners-eventName" class="headerlink" title="emitter.removeAllListeners([eventName])"></a>emitter.removeAllListeners([eventName])</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code></li>
</ul>
<p>移除全部或指定 eventName 的监听器</p>
<p>注意，在代码中移除其他地方添加的监听器是一个不好的做法，尤其是当 EventEmitter 实例是其他组件或模块（如 socket 或文件流）创建的</p>
<p>返回一个 EventEmitter 引用，可以链式调用</p>
<h3 id="emitter-removeListener-eventName-listener"><a href="#emitter-removeListener-eventName-listener" class="headerlink" title="emitter.removeListener(eventName, listener)"></a>emitter.removeListener(eventName, listener)</h3><ul>
<li><code>eventName</code> <code>&lt;any&gt;</code></li>
<li><code>listener</code> <code>&lt;Function&gt;</code></li>
</ul>
<p>从名为 eventName 的事件的监听器数组中移除指定的 listener</p>
<pre><code>const callback = (stream) =&gt; {
  console.log(&apos;有连接！&apos;);
};
server.on(&apos;connection&apos;, callback);
// ...
server.removeListener(&apos;connection&apos;, callback);
</code></pre><p><code>removeListener</code> 最多只会从监听器数组里移除一个监听器实例。 如果任何单一的监听器被多次添加到指定 <code>eventName</code> 的监听器数组中，则必须多次调用 <code>removeListener</code> 才能移除每个实例</p>
<p>注意，一旦一个事件被触发，所有绑定到它的监听器都会按顺序依次触发。 这意味着，在事件触发后、最后一个监听器完成执行前，任何 <code>removeListener()</code> 或 <code>removeAllListeners()</code> 调用都不会从 <code>emit()</code> 中移除它们。 随后的事件会像预期的那样发生</p>
<pre><code>const myEmitter = new MyEmitter();

const callbackA = () =&gt; {
  console.log(&apos;A&apos;);
  myEmitter.removeListener(&apos;event&apos;, callbackB);
};

const callbackB = () =&gt; {
  console.log(&apos;B&apos;);
};

myEmitter.on(&apos;event&apos;, callbackA);

myEmitter.on(&apos;event&apos;, callbackB);

// callbackA 移除了监听器 callbackB，但它依然会被调用。
// 触发是内部的监听器数组为 [callbackA, callbackB]
myEmitter.emit(&apos;event&apos;);
// 打印:
//   A
//   B

// callbackB 被移除了。
// 内部监听器数组为 [callbackA]
myEmitter.emit(&apos;event&apos;);
// 打印:
//   A
</code></pre><p>因为监听器是使用内部数组进行管理的，所以调用它会改变在监听器被移除后注册的任何监听器的位置索引。 虽然这不会影响监听器的调用顺序，但意味着由 <code>emitter.listeners()</code> 方法返回的监听器数组副本需要被重新创建</p>
<p>返回一个 <code>EventEmitter</code> 引用，可以链式调用</p>
<h3 id="emitter-setMaxListeners-n"><a href="#emitter-setMaxListeners-n" class="headerlink" title="emitter.setMaxListeners(n)"></a>emitter.setMaxListeners(n)</h3><ul>
<li><code>n</code> <code>&lt;integer&gt;</code></li>
</ul>
<p>默认情况下，如果为特定事件添加了超过 10 个监听器，则 <code>EventEmitter</code> 会打印一个警告。 此限制有助于寻找内存泄露。 但是，并不是所有的事件都要被限为 10 个。 <code>emitter.setMaxListeners()</code> 方法允许修改指定的 <code>EventEmitter</code> 实例的限制。 值设为 Infinity（或 0）表明不限制监听器的数量</p>
<p>返回一个 <code>EventEmitter</code> 引用，可以链式调用</p>
<h3 id="个人经验"><a href="#个人经验" class="headerlink" title="个人经验"></a>个人经验</h3><ul>
<li><p>通过查看 events 模块的源码发现 on 方法和 addListener 方法是同一个方法，没有任何区别</p>
<pre><code>EventEmitter.prototype.on = EventEmitter.prototype.addListener;
</code></pre></li>
<li><p><code>bind</code> 方法的使用</p>
<pre><code>function say(name,word) {
    console.log(name,word);
}
var newSay1 = say.bind(null);
var newSay2 = say.bind(null,&quot;张三&quot;);
newSay1(); // undefined undefined
newSay1(&quot;李四&quot;); // 李四 undefined
newSay1(&quot;李四&quot;,&quot;world&quot;); // 李四 world
// newSay2(); // 张三 undefined
newSay2(&quot;world&quot;); // 张三 world
</code></pre></li>
<li><p>模拟 <code>bind</code> 方法的实现</p>
<pre><code>function say(name,word){
    console.log(this.name,name,word);
}
var obj = {name:&apos;zfpx&apos;};
Function.prototype.bind = function(obj){
  var self = this;
    var args = Array.prototype.slice.call(arguments,1);
  return function(){
      var params = Array.prototype.slice.call(arguments);
      self.apply(obj,args.concat(params));
  }
}
var newSay = say.bind(obj,&apos;hello&apos;);

newSay(&apos;world&apos;);
</code></pre></li>
<li><p>模拟 <code>EventEmitter</code> 类的实现</p>
<pre><code>function EventEmitter(){
  this._events = {};//初始化一个私有的属性
}
//type 绑定的事件名
// listen 事件发生后的监听
EventEmitter.prototype.on = EventEmitter.prototype.addListener= function(type,listener){
   if(this._events[type]){
       this._events[type].push(listener);
   }else{
       this._events[type] = [listener];
   }
}
EventEmitter.prototype.emit = function(type){
    if(this._events[type])
        this._events[type].forEach(function(listener){
            listener();
        });
}
EventEmitter.prototype.removeListener=function(type,listener){
    if(this._events[type]){
        var listeners =  this._events[type];
        for(var i=0;i&lt;listeners.length;i++){
            if(listeners[i] === listener){
                listeners.splice(i,1);
                return;
            }
        }
    }

}
module.exports  = EventEmitter;
</code></pre></li>
</ul>
<h6 id="Node-js-v8-9-0-文档"><a href="#Node-js-v8-9-0-文档" class="headerlink" title="Node.js v8.9.0 文档"></a><a href="http://nodejs.cn/api/" title="Node.js v8.9.0 文档" target="_blank" rel="noopener">Node.js v8.9.0 文档</a></h6><blockquote>
<p>本文来源: <a href="http://www.zhufengpeixun.cn" title="珠峰培训" target="_blank" rel="noopener">珠峰培训</a></p>
<p>珠峰培训课程代码: <a href="https://github.com/zhufengnodejs/201601node" target="_blank" rel="noopener">https://github.com/zhufengnodejs/201601node</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/17/Node-js之全局对象-global/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/17/Node-js之全局对象-global/" itemprop="url">Node.js之全局对象_global</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-17T10:59:34+08:00">
                2017-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h1><ul>
<li>1.global的属性可以不用引用，也不用声明，就可以直接用</li>
<li>2.在node中在模块中能直接用有两种<ol>
<li>是全局对象下面的属性</li>
<li>初始化模块时传入的参数</li>
</ol>
</li>
<li><p>为什么能够直接在模块中访问 global,那是因为 global 也是 blobal 的属性(这句话比较绕口，但这确实是原理：自己身上有一个对自己的引用)</p>
</li>
<li><p>console</p>
<ul>
<li>console.log()</li>
<li>console.info()</li>
<li>console.error()</li>
<li>console.warn()</li>
<li>console.time()</li>
<li><p>console.timeEnd()</p>
<ul>
<li>需要传入一个字符串参数，并且要求两个方法的参数一致</li>
<li><p>用来计算在这两行代码之间的js代码执行所花费的时间，可以用来测试代码性能，对一些耗时间的代码进行针对性的优化</p>
<pre><code>console.time(&quot;test&quot;);
for (var i = 0; i &lt; 1000000; i++) {
}
console.timeEnd(&quot;test&quot;);
</code></pre></li>
</ul>
</li>
<li>日志重定向：可以把日志信息存储到一个文件中，方便日后寻找错误</li>
<li>在cmd命令窗口中通过cmd的特性使用日志重定向功能能够把log和info的输出重定向到日志文件中，如果需要把错误的日志信息也重定向到日志文件中，需要在前面加上”2”，当然普通的就是加”1”；那么就需要这样写：<code>node console.js1&gt;log.txt 2&gt;err.txt</code></li>
<li>如果还想把错误的日志信息也存放到普通的日志信息一起时，就需要这样写：<code>node console.js 1&gt;log.txt 2&gt;&amp;1</code></li>
</ul>
</li>
<li>__filename<ul>
<li>global.__filename-&gt;当前js文件的绝对路径以及文件名</li>
</ul>
</li>
<li>__dirname<ul>
<li>global.__dirname-&gt;当前js文件的绝对路径</li>
<li>这里注意 <strong>filename 和 </strong>dirname 都不是 global 的属性(试想一下，全局属性只能有一份，这样的话这两个属性值模块之间就会相互覆盖了，所以这是不存在的)，而是初始化模块时传入的参数(<strong>filename 和 </strong>dirname 是每个模块特有的)</li>
</ul>
</li>
<li>setTimeout(callback, delay[, …args])<ul>
<li>定时器(一次性执行)</li>
</ul>
</li>
<li>setImmediate(callback[, …args])<ul>
<li><code>callback</code> <code>&lt;Function&gt;</code> 在 Node.js 事件循环的当前回合结束时要调用的函数</li>
<li><code>...args</code> <code>&lt;any&gt;</code> 当调用 <code>callback</code> 时要传入的可选参数</li>
<li>返回一个用于 clearImmediate() 的 <code>Immediate</code></li>
<li>setImmediate 和 setTimeout 都是下一次执行的，但是它们谁先执行谁后执行存在几率，就是说不一定谁在前谁在后</li>
</ul>
</li>
</ul>
<h1 id="process"><a href="#process" class="headerlink" title="process"></a>process</h1><p><a href="http://www.css88.com/archives/4548" target="_blank" rel="noopener">http://www.css88.com/archives/4548</a></p>
<h3 id="process常用的方法"><a href="#process常用的方法" class="headerlink" title="process常用的方法"></a>process常用的方法</h3><ul>
<li>process.exit()：退出当前进程</li>
<li>process.stdout()-&gt;standard output</li>
<li>process.stderr()-&gt;standard error<ul>
<li>上面两个方法也是输出功能，其实console的相关输出功能就是调用了这两个方法（不管是为了减少代码的书写还是为了程序的可读性，推荐使用console对象进行输出）</li>
</ul>
</li>
<li><p>process.stdin()</p>
<ul>
<li>监听用户的输入（在监听之前需要进行编码的设置，注意这里的编码设置和之前网页内容的编码设置不同，一般这里设为”utf-8”，设为”gbk”或”gb2312”会报错）</li>
<li><p>然后通过”on”方法进行事件监听来监听用户的输入(有两种方法来获取用户的输入内容)</p>
<pre><code>process.stdin.setEncoding(&quot;utf-8&quot;);
//    process.stdin.on(&quot;data&quot;, function (data) {
//        console.log(data);
//    });
//另一种监听输入的方法：这个事件不会主动把用户的输入传到回调函数中，而需要手动的通过方法来获取
process.stdin.on(&quot;readable&quot;, function () {
    var data = process.stdin.read();
    console.log(data);
});
</code></pre></li>
</ul>
</li>
<li><p>process.cwd()</p>
<ul>
<li><p>cwd-&gt;current working dir;很容易和__dirname搞混(返回运行当前脚本的工作目录的路径)</p>
<pre><code>console.log(&quot;dirname:&quot; + __dirname);//dirname-&gt;js文件所在目录
console.log(&quot;cwd:&quot; + process.cwd());//cwd()-&gt;执行node命令时，我们在哪个目录
//例如cwd_subdir.js在subdir文件夹中，进入subdir的上一级目录，当在cmd窗口中这样执行时效果非常明显:node subdir/cwd_subdir.js
//dirname-&gt;js文件所在目录(就会到subdir这个目录)
//cwd()-&gt;执行node命令时，我们在哪个目录(这里就会是subdir的上一级目录)
</code></pre></li>
</ul>
</li>
<li>process.chdir()<ul>
<li>方法变更Node.js进程的当前工作目录，如果变更目录失败会抛出异常(例如，如果指定的目录不存在)(改变工作目录)</li>
</ul>
</li>
<li>process.memoryUsage()<ul>
<li>返回Node.js进程的内存使用情况的对象，该对象每个属性值的单位为字节</li>
</ul>
</li>
<li><p>process.nextTick()</p>
<ul>
<li>将 callback 添加到”next tick 队列”。 一旦当前事件轮询队列的任务全部完成，在next tick队列中的所有callbacks会被依次调用(将一个回调函数放在下次事件循环的顶部)</li>
<li><p>这种方式不是 <code>setTimeout(fn, 0)</code> 的别名。它更加有效率。事件轮询随后的ticks 调用，会在任何I/O事件（包括定时器）之前运行</p>
<pre><code>console.log(&apos;start&apos;);
process.nextTick(() =&gt; {
  console.log(&apos;nextTick callback&apos;);
});
console.log(&apos;scheduled&apos;);
// Output:
// start
// scheduled
// nextTick callback
</code></pre></li>
</ul>
</li>
</ul>
<h3 id="process常用的事件"><a href="#process常用的事件" class="headerlink" title="process常用的事件"></a>process常用的事件</h3><ul>
<li>“exit”-&gt;程序正常的退出触发执行</li>
<li><p>“SIGINT”(signal interrupted)-&gt;程序运行时出现一个中断信号触发执行</p>
<pre><code>//process事件：
process.on(&quot;exit&quot;, function () {
    console.log(&quot;programe will exit.&quot;);
});//在程序正常退出前执行
process.on(&quot;SIGINT&quot;, function () {
    console.log(&quot;programe has a sigint.&quot;);//（这里可以在用户按下&quot;ctrl+c&quot;强制退出前做一些必要的操作，然后再执行下面的方法退出）
    process.exit();//在处理中断的回调函数中让程序正常退出
});//例如之前监听用户输入时按下&quot;ctrl+c&quot;结束监听时就会产生一个中断信号
</code></pre></li>
</ul>
<h3 id="process常用的属性"><a href="#process常用的属性" class="headerlink" title="process常用的属性"></a>process常用的属性</h3><ul>
<li>process.argv<ul>
<li>返回一个数组，这个数组包含了启动Node.js进程时的命令行参数(当前进程的命令行参数数组)<ul>
<li>是一个数组，里面的内容是执行node命令时一条命令中以空格隔开的各项内容；其中第一项是node命令，第二项是执行的js文件的绝对路径；因此也就能通过这个属性来获取当执行node命令时在后面附加的其他参数（由于第0,1项都被占用了，所以其实是从第2项开始的）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="Node-js-v8-9-0-文档"><a href="#Node-js-v8-9-0-文档" class="headerlink" title="Node.js v8.9.0 文档"></a><a href="http://nodejs.cn/api/" title="Node.js v8.9.0 文档" target="_blank" rel="noopener">Node.js v8.9.0 文档</a></h6><blockquote>
<p>本文来源: <a href="http://www.zhufengpeixun.cn" title="珠峰培训" target="_blank" rel="noopener">珠峰培训</a></p>
<p>珠峰培训课程代码: <a href="https://github.com/zhufengnodejs/201601node" target="_blank" rel="noopener">https://github.com/zhufengnodejs/201601node</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/14/Node-js之ajax/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/14/Node-js之ajax/" itemprop="url">Node.js之ajax</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-14T21:38:53+08:00">
                2017-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一步-创建-ajax-对象"><a href="#第一步-创建-ajax-对象" class="headerlink" title="第一步    创建 ajax 对象"></a>第一步    <strong>创建</strong> <code>ajax</code> 对象</h1><p><code>var XHR = new XMLHttpRequest();</code></p>
<h1 id="第二步-打开请求"><a href="#第二步-打开请求" class="headerlink" title="第二步    打开请求"></a>第二步    <strong>打开</strong>请求</h1><p><code>xhr.open(method, url, async, user, password);</code></p>
<h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><p><img src="/img/open.png" alt="open.png" title="open.png"></p>
<h1 id="第三步-指定接收响应的-回调函数"><a href="#第三步-指定接收响应的-回调函数" class="headerlink" title="第三步    指定接收响应的 回调函数"></a>第三步    指定接收响应的 回调函数</h1><ul>
<li><p>当 XMLHTTPRequest 对象的 <code>readyState</code> 属性改变时调用回调函数</p>
<p>  <code>xhr.onreadystatechange = function(){};</code></p>
</li>
</ul>
<h1 id="XHR-对象状态"><a href="#XHR-对象状态" class="headerlink" title="XHR 对象状态"></a>XHR 对象状态</h1><p><img src="/img/readyState1.png" alt="readyState1.png" title="readyState1.png"></p>
<h1 id="readyState-状态的值"><a href="#readyState-状态的值" class="headerlink" title="readyState 状态的值"></a><code>readyState</code> 状态的<strong>值</strong></h1><p><img src="/img/readyState2.png" alt="readyState2.png" title="readyState2.png"></p>
<h1 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h1><p><img src="/img/response.png" alt="response.png" title="response.png"></p>
<h1 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h1><ul>
<li><code>send</code> 方法会把参数放到<strong>请求体</strong>里</li>
<li>所有 <code>get</code> 不能通过请求体传<strong>参数</strong>，而 <code>post</code> 可以</li>
<li><p>当使用同步的时候，<code>send</code> 方法后都会阻塞，一直等到服务器响应，所以 <code>send</code> 方法要放到<strong>最后</strong></p>
<p>  <code>xhr.send(varBody);</code></p>
</li>
</ul>
<h3 id="send-方法重载参数"><a href="#send-方法重载参数" class="headerlink" title="send 方法重载参数"></a><code>send</code> 方法重载参数</h3><p><img src="/img/send.png" alt="send.png" title="send.png"></p>
<h1 id="form-标签的-enctype-属性"><a href="#form-标签的-enctype-属性" class="headerlink" title="form 标签的 enctype 属性"></a><code>form</code> 标签的 <code>enctype</code> 属性</h1><p><img src="/img/form_enctype.png" alt="form_enctype.png" title="form_enctype.png"></p>
<h1 id="xhr-对象的方法"><a href="#xhr-对象的方法" class="headerlink" title="xhr 对象的方法"></a><code>xhr</code> 对象的<strong>方法</strong></h1><p><img src="/img/xhr_function.png" alt="xhr_function.png" title="xhr_function.png"></p>
<h1 id="xhr-对象的属性"><a href="#xhr-对象的属性" class="headerlink" title="xhr 对象的属性"></a><code>xhr</code> 对象的<strong>属性</strong></h1><p><img src="/img/xhr_attr.png" alt="xhr_attr.png" title="xhr_attr.png"></p>
<h1 id="responseType-响应类型"><a href="#responseType-响应类型" class="headerlink" title="responseType 响应类型"></a><code>responseType</code> 响应类型</h1><ul>
<li><code>XMLHttpRequest.responseType</code> 设置该值能够改变响应类型，设置后会把 <code>XMLHttpRequest.response</code> 转化为相应的类型<br><img src="/img/responseType.png" alt="responseType.png" title="responseType.png"></li>
</ul>
<h1 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h1><p>文件上传、预览、删除等功能: <a href="http://blog.csdn.net/qingyjl/article/details/52003567" target="_blank" rel="noopener">http://blog.csdn.net/qingyjl/article/details/52003567</a></p>
<ul>
<li><p>上传图片需要使用 <code>type=&quot;file&quot;</code> 类型的 <code>input</code> 元素</p>
<p>  <code>&lt;input type=&quot;file&quot; multiple  name=&quot;avatar&quot;&gt;</code></p>
<p>  其中 <code>multiple</code> 属性是用来上传多张图片的， <code>name</code> 属性可以自定义</p>
</li>
<li>把上传后的图片显示出来<ol>
<li>在服务器端，把 files 里的 avatar 里的path读出来，根据此路径通过 <code>fs.readFile</code> 方法把图片复制到 imgs 目录下</li>
<li>把此图片的路径返回浏览器端</li>
<li>在浏览器端构建一个 img 元素，追加到 body 上，并且指定 img 的 src 属性，此处 src 属性值为服务器返回的图片路径</li>
<li>服务器端可以接收客户端发出的请求图片的请求，服务器返回图片的内容，最终在浏览器端图片得到显示</li>
</ol>
</li>
</ul>
<h1 id="FormData-对象-H5-新对象-的使用"><a href="#FormData-对象-H5-新对象-的使用" class="headerlink" title="FormData 对象(H5 新对象)的使用"></a><code>FormData</code> 对象(H5 新对象)的使用</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects</a></p>
<p><a href="https://www.cnblogs.com/lhb25/p/html5-formdata-tutorials.html" target="_blank" rel="noopener">https://www.cnblogs.com/lhb25/p/html5-formdata-tutorials.html</a></p>
<h3 id="通过FormData对象可以组装一组用-XMLHttpRequest发送请求的键-值对。它可以更灵活方便的发送表单数据，因为可以独立于表单使用。如果你把表单的编码类型设置为multipart-form-data-，则通过FormData传输的数据格式和表单通过submit-方法传输的数据格式相同"><a href="#通过FormData对象可以组装一组用-XMLHttpRequest发送请求的键-值对。它可以更灵活方便的发送表单数据，因为可以独立于表单使用。如果你把表单的编码类型设置为multipart-form-data-，则通过FormData传输的数据格式和表单通过submit-方法传输的数据格式相同" class="headerlink" title="通过FormData对象可以组装一组用 XMLHttpRequest发送请求的键/值对。它可以更灵活方便的发送表单数据，因为可以独立于表单使用。如果你把表单的编码类型设置为multipart/form-data ，则通过FormData传输的数据格式和表单通过submit() 方法传输的数据格式相同"></a>通过FormData对象可以组装一组用 XMLHttpRequest发送请求的键/值对。它可以更灵活方便的发送表单数据，因为可以独立于表单使用。如果你把表单的编码类型设置为multipart/form-data ，则通过FormData传输的数据格式和表单通过submit() 方法传输的数据格式相同</h3><pre><code>//准备发送给服务器的数据
var formData = new FormData();
//给这个表单对象增加一个表单元素
formData.append(&apos;username&apos;,document.querySelector(&apos;input[name=username]&apos;).value);
//给这个表单对象增加一个表单元素
formData.append(&apos;password&apos;,document.querySelector(&apos;input[name=password]&apos;).value);
var avatar = document.querySelector(&apos;input[name=avatar]&apos;)
//给这个表单对象增加一个文件元素
formData.append(&apos;avatar&apos;,avatar.files[0]);
xhr.send(formData);
</code></pre><h1 id="formidable-模块"><a href="#formidable-模块" class="headerlink" title="formidable 模块"></a><code>formidable</code> 模块</h1><p><a href="http://blog.csdn.net/charlene0824/article/details/51234394" target="_blank" rel="noopener">http://blog.csdn.net/charlene0824/article/details/51234394</a></p>
<pre><code>if (pathname == &apos;/reg2&apos;) {
    // 构建一个解析器
    var formParser = new formidable.IncomingForm();
    ///用解析器解析请求体
    //非file的input会放在fields里
    //文件类型的元素会放在files里(文件这么分类都是 parse 方法自动处理的)
    formParser.parse(req, function (err, fields, files) {
        fs.readFile(files.avatar.path, function (err, data) {
            console.log(files.avatar);
            var filename = &apos;/imgs/&apos; + files.avatar.name; // 创建存放图片的目录
            fs.writeFile(&apos;.&apos; + filename, data, function (err) { // 根据此路径通过 fs.readFile 方法复制图片
                res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});
                res.end(filename); // 把此图片的路径返回浏览器端
            })
        })
    });
}

// files
{ avatar: 
   File {
     domain: null,
     _events: {},
     _eventsCount: 0,
     _maxListeners: undefined,
     size: 42271,
     path: &apos;C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\upload_11b9e023ed180f1f0cb33f5a23fae377&apos;,
     name: &apos;boy.png&apos;,
     type: &apos;image/png&apos;,
     hash: null,
     lastModifiedDate: 2017-12-15T04:11:11.380Z,
     _writeStream: 
      WriteStream {
        _writableState: [Object],
        writable: false,
        domain: null,
        _events: {},
        _eventsCount: 0,
        _maxListeners: undefined,
        path: &apos;C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\upload_11b9e023ed180f1f0cb33f5a23fae377&apos;,
        fd: null,
        flags: &apos;w&apos;,
        mode: 438,
        start: undefined,
        autoClose: true,
        pos: undefined,
        bytesWritten: 42271,
        closed: true 
      } 
    } 
}
</code></pre><h1 id="querystring-模块"><a href="#querystring-模块" class="headerlink" title="querystring 模块"></a><code>querystring</code> 模块</h1><p><a href="http://yijiebuyi.com/blog/d37512fc6df0fc4d0adfc2ec5c3d46ff.html" target="_blank" rel="noopener">http://yijiebuyi.com/blog/d37512fc6df0fc4d0adfc2ec5c3d46ff.html</a></p>
<h3 id="node-js原生自带，直接-require-‘querystring’-即可使用"><a href="#node-js原生自带，直接-require-‘querystring’-即可使用" class="headerlink" title="node.js原生自带，直接 require(‘querystring’) 即可使用"></a>node.js原生自带，直接 require(‘querystring’) 即可使用</h3><ul>
<li><p>querystring.parse(str, [sep], [eq], [options])</p>
<p>  参数字符串(查询字符串)格式化成对象</p>
<pre><code>var obj={name:&quot;一介布衣&quot;,url:&quot;http://yijiebuyi.com&quot;};
var param= querystring.stringify(obj);
</code></pre><p>  我们把param 字符串格式化成对象,使用默认分隔分配符</p>
<pre><code>var newobj=querystring.parse(param);
console.log(typeof newobj,newobj);
</code></pre><p>  打印出来格式化后的数据类型 和 内容<br><img src="/img/querystring_parse1.png" alt="querystring_parse1.png" title="querystring_parse1.png"></p>
<p>  可以看到格式化以后是object类型,并且汉字自动解码显示出来.<br>  当覆盖分割和分配符,如下:</p>
<pre><code>param=querystring.stringify(obj,&apos;|&apos;,&apos;*&apos;);
console.log(param);
</code></pre><p><img src="/img/querystring_parse2.png" alt="querystring_parse2.png" title="querystring_parse2.png"></p>
</li>
<li><p>querystring.stringify(obj, [sep], [eq])</p>
<p>  对象格式化成参数字符串 ,obj就是要格式化的对象,必选参数</p>
<pre><code>var obj={name:&quot;一介布衣&quot;,url:&quot;http://yijiebuyi.com&quot;};
var param= querystring.stringify(obj);
//没有指定分隔符和分配符,并且自动编码汉字
console.log(param);
</code></pre><p><img src="/img/querystring_stringify1.png" alt="querystring_stringify1.png" title="querystring_stringify1.png"></p>
<pre><code>param=querystring.stringify(obj,&apos;|&apos;,&apos;*&apos;);
//指定了分隔符和分配符
console.log(param);
</code></pre><p><img src="/img/querystring_stringify2.png" alt="querystring_stringify2.png" title="querystring_stringify2.png"></p>
</li>
</ul>
<h1 id="util-模块"><a href="#util-模块" class="headerlink" title="util 模块"></a><code>util</code> 模块</h1><p><a href="http://www.runoob.com/nodejs/nodejs-util.html" target="_blank" rel="noopener">http://www.runoob.com/nodejs/nodejs-util.html</a></p>
<ul>
<li>util.inspect(object,[showHidden],[depth],[colors])<br>  util.inspect 是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出；它至少接受一个参数 object，即要转换的对象<ul>
<li>showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息</li>
<li>depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少；如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象</li>
<li>如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果<blockquote>
<p>特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>代码示例：</p>
<pre><code>var util = require(&apos;util&apos;); 
function Person() { 
    this.name = &apos;byvoid&apos;; 
    this.toString = function() { 
    return this.name; 
    }; 
} 
var obj = new Person(); 
console.log(util.inspect(obj)); 
console.log(util.inspect(obj, true));
</code></pre><p>运行结果是：</p>
<pre><code>Person { name: &apos;byvoid&apos;, toString: [Function] }
Person {
  name: &apos;byvoid&apos;,
  toString: 
   { [Function]
     [length]: 0,
     [name]: &apos;&apos;,
     [arguments]: null,
     [caller]: null,
     [prototype]: { [constructor]: [Circular] } } }
</code></pre><ul>
<li>util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数</li>
</ul>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf</a></p>
<ul>
<li><p>示例如下：</p>
<pre><code>var util = require(&apos;util&apos;); 
function Base() { 
    this.name = &apos;base&apos;; 
    this.base = 1991; 
    this.sayHello = function() { 
    console.log(&apos;Hello &apos; + this.name); 
    }; 
} 
Base.prototype.showName = function() { 
    console.log(this.name);
}; 
function Sub() { 
    this.name = &apos;sub&apos;; 
} 
util.inherits(Sub, Base); 
var objBase = new Base(); 
objBase.showName(); 
objBase.sayHello(); 
console.log(objBase); 
var objSub = new Sub(); 
objSub.showName(); 
//objSub.sayHello(); 
console.log(objSub); 
</code></pre></li>
<li><p>我们定义了一个基础对象Base 和一个继承自Base 的Sub，Base 有三个在构造函数 内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承。运行结果如下：</p>
<pre><code>base 
Hello base 
{ name: &apos;base&apos;, base: 1991, sayHello: [Function] } 
sub 
{ name: &apos;sub&apos; }
</code></pre></li>
<li><p>注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。<br>同时，在原型中定义的属性不会被console.log 作 为对象的属性输出。如果我们去掉 objSub.sayHello(); 这行的注释，将会看到：</p>
<pre><code>node.js:201 
throw e; // process.nextTick error, or &apos;error&apos; event on first tick 
^ 
TypeError: Object #&amp;lt;Sub&amp;gt; has no method &apos;sayHello&apos; 
</code></pre></li>
<li><p>util.inherits(Children,Parent) <code>&lt;Child,Parent是两个类&gt;</code> 实现原理：<code>Object.setPrototypeOf(ctor.prototype,superCtor.prototype)-&gt; Children.prototype=new Parent();</code></p>
<pre><code>util.inherits(Children,Parent)
// 解释：
function temp() {}
temp.prototype=Parent.prototype;
Children.prototype=new temp();
</code></pre></li>
<li><p>通过 <code>Parent.call(this);</code> 实现子类对父类在非原型上的自定义的属性的继承</p>
<pre><code>function Children() {
    Parent.call(this);
    this.name = &quot;children&quot;;
}
</code></pre></li>
<li><p>util.isArray(object)</p>
<ul>
<li>如果给定的参数 “object” 是一个数组返回true，否则返回false</li>
</ul>
</li>
<li>util.isRegExp(object)<ul>
<li>如果给定的参数 “object” 是一个正则表达式返回true，否则返回false</li>
</ul>
</li>
<li>util.isDate(object)<ul>
<li>如果给定的参数 “object” 是一个日期返回true，否则返回false</li>
</ul>
</li>
<li>util.isError(object)<ul>
<li>如果给定的参数 “object” 是一个错误对象返回true，否则返回false</li>
</ul>
</li>
</ul>
<h1 id="mime-模块"><a href="#mime-模块" class="headerlink" title="mime 模块"></a><code>mime</code> 模块</h1><p><a href="https://www.cnblogs.com/jeacy/p/6992435.html" target="_blank" rel="noopener">https://www.cnblogs.com/jeacy/p/6992435.html</a></p>
<pre><code>// 在使用nodejs中的mime模块处理静态文件的时候，出现mime.lookup的错误，
// 具体错误如下：
// mime.lookup is not a function
// 原因是：mime 2.x.x 版本修改了函数名: lookup() -&gt; getType()
</code></pre><h1 id="url-模块"><a href="#url-模块" class="headerlink" title="url 模块"></a><code>url</code> 模块</h1><p><a href="http://blog.csdn.net/vanhukseter/article/details/43870271" target="_blank" rel="noopener">http://blog.csdn.net/vanhukseter/article/details/43870271</a></p>
<ul>
<li><p>url.parse(urlString,boolean,boolean)</p>
<p>  parse 这个方法可以将一个url的字符串解析并返回一个url的对象</p>
<p>  参数：urlString 指传入一个url地址的字符串</p>
</li>
</ul>
<p>　　　　　第二个参数（可省）传入一个布尔值，默认为false，为true时，返回的url对象中，query的属性为一个对象。</p>
<p>　　　　　第三个参数（可省）传入一个布尔值，默认为false，为true时，解析时会将url的”//”和第一个”/”之间的部分解析为主机名</p>
<p>示例:</p>
<pre><code>var url = require(&apos;url&apos;);
url.parse(&apos;http://www.baidu.com/news&apos;,false,true);
</code></pre><p>返回的结果：</p>
<pre><code>{ protocol: &apos;http:&apos;,
  slashes: true,
  auth: null,
  host: &apos;www.baidu.com&apos;,
  port: null,
  hostname: &apos;www.baidu.com&apos;,
  hash: null,
  search: null,
  query: null,
  pathname: &apos;/news&apos;,
  path: &apos;/news&apos;,
  href: &apos;http://www.baidu.com/news&apos; }
</code></pre><h1 id="request-的-data-事件"><a href="#request-的-data-事件" class="headerlink" title="request 的 data 事件"></a>request 的 <code>data</code> 事件</h1><p><a href="http://www.runoob.com/nodejs/node-js-get-post.html" target="_blank" rel="noopener">http://www.runoob.com/nodejs/node-js-get-post.html</a></p>
<pre><code>if(pathname == &apos;/reg&apos;){
    var result=&apos;&apos;;
    //当读到客户端提交过来的数据时会触发data事件，然后调用回调函数(通过req的data事件监听函数，每当接受到请求体的数据，就累加到result变量中)
    req.on(&apos;data&apos;,function(data){
        result +=data;
    })
    req.on(&apos;end&apos;,function(){
        // 数据接收完毕(在end事件触发后，通过querystring.parse将result解析为真正的POST请求格式，然后向客户端返回)
        result = querystring.parse(result);
        res.end(util.inspect(result)); // 发送响应
    })
}
</code></pre><h1 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h1><pre><code>/**
     *  . 当前目录
     *  ./index.js 当前目录下的某个文件
     *  / 1. 如果是在HTML的链接里，代表URL 根目录
     *    2. 如果出现在读文件的时候,则它代理当前盘符的根目录
     *  index.js 代表当前目录下面的index.js文件 == ./index.js
     *  .. 代表上一级目录
     *  ../../ 代表上一级的上一级目录
     */
</code></pre><h1 id="处理表单数据"><a href="#处理表单数据" class="headerlink" title="处理表单数据"></a>处理表单数据</h1><h3 id="处理成一个数组"><a href="#处理成一个数组" class="headerlink" title="处理成一个数组"></a>处理成一个数组</h3><pre><code>function serialize(form) {
    // 把表单中的元素集合转成一个数组
    var elements = Array.prototype.slice.call(form.elements);
    var data = [];
    // 循环这个数组
    elements.forEach(function (element) {
        //先取出元素的类型
        var type = element.type;
        switch (type) {
            case &apos;submit&apos;:
            case &apos;cancel&apos;:
            case &apos;reset&apos;:
                break;
            case &apos;text&apos;:
                data.push(element.name + &apos;=&apos; + element.value); // 把 type=&quot;text&quot; 的 input 元素添加至数组中，得到一个字符串数组
        }
    });
    // 通过 join 方法将该数组以 &apos;&amp;&apos; 为分割符转换为字符串并返回
    return data.join(&apos;&amp;&apos;);
}

// 把表单的数据 转成查询字符串
var data = serialize(document.querySelector(&apos;form&apos;));
// 把数据放在请求体里发送给服务器
xhr.send(data);
</code></pre><h3 id="处理成一个对象"><a href="#处理成一个对象" class="headerlink" title="处理成一个对象"></a>处理成一个对象</h3><pre><code>function toJson(form) {
    // 把表单中的元素集合转成一个 JSON 格式对象
    var elements = Array.prototype.slice.call(form.elements);
    var data = {};
    // 循环这个数组
    elements.forEach(function (element) {
        // 先取出元素的类型
        var type = element.type;
        switch (type) {
            case &apos;submit&apos;:
            case &apos;cancel&apos;:
            case &apos;reset&apos;:
                break;
            case &apos;text&apos;:
                data[element.name] = element.value; // 把 type=&quot;text&quot; 的 input 元素以 key-value 形式将表单元素的 name 和 value 添加至对象中
        }
    });
    // 返回该对象
    return data;
}

// 把表单的数据 转成 JSON 对象
var data = toJson(document.querySelector(&apos;form&apos;));
//把数据放在请求体里发送给服务器，注意不能直接把对象发送给服务器，需要转成字符串的形式
xhr.send(JSON.stringify(data));
</code></pre><h1 id="ajax-请求注意事项"><a href="#ajax-请求注意事项" class="headerlink" title="ajax 请求注意事项"></a><code>ajax</code> 请求注意事项</h1><ul>
<li>xhr.send() 方法不要错误的放到 onreadystatechange 对应的回调函数中去，那样不会发送请求(这个错误比较隐晦，不容易被发现)</li>
<li>异步请求时xhr.send() 是异步执行的方法，所以 onreadystatechange 方法可以放在 send 方法的前面和后面都可以；但是当为同步请求时，onreadystatechange 方法一定要放在 send 方法的前面，否则无法操作返回的数据</li>
<li>只有当提交form表单，并且是GET请求的时候，浏览器才会把表单进行序列化(参数字符串)拼到URL后面(因为GET请求没有请求体)</li>
<li>在 form 起始标签中可以通过 “method” 来指定是 “GET” 还是 “POST” 请求</li>
<li>只有 type=”submit” 的按钮在点击后才会生成查询字符串(参数字符串) -&gt; <input type="submit" value="注册">;<input type="button" id="regBtn" value="注册"> 这样是不会生成参数字符串的</li>
<li>POST 请求也不会生成参数字符串，因为 POST 请求会把它放到请求体里面</li>
<li>xhr.setRequestHeader(‘Content-Type’,’application/x-www-form-urlencoded’); //设置请求头，不同的数据格式要采用不同的数据编码方式，而且这里设置的编码方式要和下面 send 方法中传递的数据的格式一致；为什么要相同呢？ -&gt; 因为服务器就是通过 Content-Type 来确定客户端发送的数据格式的，从而进行相关的数据解析，如果不一致的话，服务器解析就会出错</li>
<li>在 form 表单中通过 enctype 属性来设置编码方式，当需要上传图片时，值为 “multipart/form-data”</li>
<li>我们通过 xhr.send() 发送请求数据是中间步骤，为什么要先写 xhr.responseType=”json”; xhr.onreadystatechange=function() {}; …获取响应信息的代码. 最后写 xhr.send();这其实和绑定点击事件是一个道理，先要给点击事件绑定相应的方法，然后再点击；如果已经点击了再绑定方法就没用了</li>
<li>使用 fs.exists(path, callback) 方法时，注意 path 如果是相对路径下的当前路径，记得要在路径前加上 “.”</li>
<li>服务器配置路由时最后应该要配置其他所有未明确指定路径应该访问的资源，这样就不会导致客户端访问已有资源时出错(而且在服务端，html 文件引入 js 文件的相对路径前可以添加任意多个 “../“，因为添加的这些貌似不会对服务器读取资源产生任何影响，如： ../../js/index.js 与 ../js/index.js 与 index.js 都是相同的效果；但是如果添加一些指定的不存在的路径时，比如： /test/js/index.js 就会请求资源出错；以上只针对于服务端，当在本地预览 html 页面时，还是应该正确书写引用文件路径，如： ../js/index.js)</li>
</ul>
<h1 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h1><ul>
<li><p>Fiddler</p>
<p>  目前最常用的http抓包工具之一</p>
</li>
</ul>
<blockquote>
<p>本文来源: <a href="http://www.zhufengpeixun.cn" title="珠峰培训" target="_blank" rel="noopener">珠峰培训</a></p>
<p>珠峰培训课程代码: <a href="https://github.com/zhufengnodejs/201601node" target="_blank" rel="noopener">https://github.com/zhufengnodejs/201601node</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/12/Node-js之http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/12/Node-js之http/" itemprop="url">Node.js之http</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-12T23:09:02+08:00">
                2017-12-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="命令行中执行"><a href="#命令行中执行" class="headerlink" title="命令行中执行"></a>命令行中执行</h1><ul>
<li>命令行窗口中： <code>netstat</code> 命令用于显示各种网络相关信息</li>
<li><p>也可以通过 git bash 命令行窗口来访问服务器</p>
<p>  输入命令： curl <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> / curl -v <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>  (可以是任意可访问的地址)</p>
<p>  可以看到请求和响应的内容</p>
<p>  User-Agent: 代表客户端的代理（每种浏览器的代理都不一样，服务器用这个来判断客户端类型），此时命令行中的代理就是 curl</p>
<p>  Accept: 代表可以接接收的结果类型(可以指定是接收html还是js，<em>/</em>代表任意)</p>
<p>  Transfer-Encoding: chunked -&gt; 传输的编码(chunked:分块传输)</p>
</li>
</ul>
<p><img src="/img/http_curl.png" alt="http_curl" title="http_curl.png"></p>
<ul>
<li>利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障；应用格式：Ping空格IP地址。该命令还可以加许多参数使用，具体是键入Ping按回车即可看到详细说明</li>
</ul>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><ul>
<li>服务器可以是<strong>专业</strong>服务器也可以是<strong>个人</strong>电脑</li>
<li>能在<strong>特定(IP)服务器</strong>的<strong>特定端口</strong>上监听客户端的请求，并根据请求的路径返回相应结果都叫服务器</li>
</ul>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><ul>
<li>只要能向<strong>特定(IP)服务器</strong>的<strong>特定端口</strong>发起请求并接受响应的都叫客户端</li>
</ul>
<h1 id="数据在服务器和客户端之间传递"><a href="#数据在服务器和客户端之间传递" class="headerlink" title="数据在服务器和客户端之间传递"></a>数据在服务器和客户端之间传递</h1><ul>
<li>可以把服务器硬盘上的<strong>已经有的静态文件</strong>发送给客户端</li>
<li>也可以由服务器经过逻辑处理生成的<strong>动态内容</strong>返回给客户端，比如<strong>当前时间</strong></li>
<li>一个 http 事务由一条(从客户端发往服务器的)请求命令和一个(从服务器发回客户端的)响应结果组成</li>
</ul>
<h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><ul>
<li>人与人之间通信，需要一种<strong>传输手段</strong>(声波)和一种彼此抖动的语言(比如普通话)</li>
<li>要让这些形形色色的机器能够通过网络进行交互，我们就需要指明一种<strong>协议</strong>(比如 HTTP/HTTPS)和一种<strong>数据封装格式</strong>(比如 HTML/JSON)</li>
<li>http 指的就是这种协议 + 数据格式的交流体系<br><img src="/img/http.png" alt="http" title="http.png"></li>
</ul>
<h1 id="一个普通网站访问的过程-1"><a href="#一个普通网站访问的过程-1" class="headerlink" title="一个普通网站访问的过程(1)"></a>一个普通网站访问的过程(1)</h1><h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程(1)"></a>过程(1)</h2><ul>
<li>浏览器(或其他客户端，如：微信)向服务器发起一个<strong>HTTP请求</strong></li>
<li>先把<strong>域名解析为IP地址</strong>(chrome 缓存1分钟(chrome://net-internals/#dns) -&gt; 搜索操作系统缓存 -&gt; 读取本地 host 文件 -&gt; 打气 DNS 系统调用 -&gt; 运营商 DNS 缓存 -&gt; 找根域 -&gt; com 域)</li>
<li>哭护短通过随机端口向服务器发起 TCP 三次握手，建立了 <strong>TCP 连接</strong></li>
<li>连接建立后浏览器就可以 <strong>发送HTTP请求</strong>了</li>
<li>服务器接收到 HTTP 请求，解析请求的路径和参数，经过后台的一些处理之后<strong>生成完整响应</strong>页面</li>
<li>服务器将生成的页面作为 HTTP 响应体，根据不同的处理结果生成 响应头，发回给客户端</li>
</ul>
<h2 id="过程-2"><a href="#过程-2" class="headerlink" title="过程(2)"></a>过程(2)</h2><ul>
<li>客户端(浏览器)接收到 HTTP 响应，从请求中得到的 HTTP 响应体里是 HTML 代码，于是对 HTML 代码开始解析</li>
<li>解析过程中遇到<strong>引用的服务器上的资源</strong>(额外的CSS、JS代码、图片、音视频、附件等等)，再向服务器发送请求</li>
<li>浏览器解析 HTML 包含的内容，用得到的 CSS 代码进行外观上的进一步<strong>渲染</strong>，JS 代码也可能会对外观进行一定的<strong>处理</strong></li>
<li>当客户与<strong>页面交互</strong>(点击、悬停等等)时，JS 代码对此作出一定的反应，添加特效与动画</li>
<li>交互的过程中可能需要向服务器索取或提交额外的数据(局部的刷新)，一般不是通过跳转就是通过 JS 代码(响应某个动作或者定时)向服务器发送<strong>AJAX</strong>请求</li>
<li>服务器再把客户端需要的资源返回，客户端用得到的资源来实现动态效果或者<strong>修改 DOM 结构</strong></li>
</ul>
<h1 id="请求的方式"><a href="#请求的方式" class="headerlink" title="请求的方式"></a>请求的方式</h1><ul>
<li><code>GET</code></li>
</ul>
<p>从服务器获取资源，比如请求一张空白的注册表单</p>
<ul>
<li><code>POST</code></li>
</ul>
<p>向服务器提交数据，比如提交注册表单</p>
<h1 id="请求的-URL"><a href="#请求的-URL" class="headerlink" title="请求的 URL"></a>请求的 <code>URL</code></h1><p><img src="/img/http_url.png" alt="http_url" title="http_url.png"></p>
<h1 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h1><ul>
<li>每条 http 请求报文都包括一个方法表示本次将要进行何种类型的操作，如入去一个页面，删除一个资源</li>
<li>GET 是用来从服务器获取数据，没有请求体，不会影响服务器端的数据</li>
<li>POST 是用来将数据发送到服务器，post 会把要发送的数据放到请求体中，可能会影响到服务器端的数据<br>简单说明:<br><img src="/img/http_method1.png" alt="http_method1" title="method_method1.png"><br>详细说明(来源于<a href="http://www.runoob.com/http/http-methods.html" title="菜鸟教程" target="_blank" rel="noopener">菜鸟教程</a>):<br><img src="/img/http_method2.png" alt="http_method2" title="method_method2.png"></li>
</ul>
<h1 id="常见请求头信息"><a href="#常见请求头信息" class="headerlink" title="常见请求头信息"></a>常见请求头信息</h1><h3 id="从客户端发往服务器发送请求报文所使用的字段，用于补充请求的附加信息"><a href="#从客户端发往服务器发送请求报文所使用的字段，用于补充请求的附加信息" class="headerlink" title="从客户端发往服务器发送请求报文所使用的字段，用于补充请求的附加信息"></a>从客户端发往服务器发送请求报文所使用的字段，用于补充请求的附加信息</h3><ul>
<li><p><code>host</code></p>
<p>  请求的服务主机；HTTP/1.1 请求必须包含主机头，否则会返回 <code>404</code> 状态码</p>
</li>
<li><p><code>connection</code></p>
<p>  客户端和服务器<strong>连接</strong>选项</p>
</li>
<li><p><code>accept</code></p>
<p>  告诉服务器客户端能够处理的<strong>内容类型</strong>和<strong>优先级</strong><br>  q=表示权重，用分号隔开<code>;</code>,范围是0-1，不指定时权重默认为1</p>
</li>
<li><p><code>user-agent</code></p>
<p>  <strong>用户代理</strong>，是指浏览器，它的信息包括硬件平台，系统软件，应用软件和用户个人偏好</p>
</li>
<li><p><code>accept-encoding</code></p>
<p>  告诉服务器哭护短支持的<strong>内容编码</strong>及内容编码的<strong>优先级</strong>顺序</p>
</li>
<li><p><code>accept-language</code></p>
<p>  告诉服务器能够处理的<strong>语言</strong>以及优先级</p>
</li>
</ul>
<h1 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h1><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p><img src="/img/http_message_request.png" alt="http_message_request" title="http_message_request.png"></p>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p><img src="/img/http_message_response.png" alt="http_message_response" title="http_message_response.png"></p>
<h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><ul>
<li>状态码是一个三单位数字的代码，告知响应结果的类型</li>
<li>伴随着每个数字状态码，http 还会发送一条解释性的原因短语文本</li>
</ul>
<h2 id="状态码类型"><a href="#状态码类型" class="headerlink" title="状态码类型"></a>状态码类型</h2><ul>
<li><p>1xx</p>
<p>  请求正在处理</p>
</li>
<li><p>2xx</p>
<p>  请求处理完成</p>
<ul>
<li><code>200 OK</code> 请求成功</li>
</ul>
</li>
<li><p>3xx</p>
<p>  重定向</p>
<ul>
<li><code>301 Moved Permanently</code> 永久重定向</li>
<li><code>302 Found</code> 临时重定向</li>
</ul>
</li>
<li><p>4xx</p>
<p>  客户端错误</p>
<ul>
<li><code>400 Bad request</code> 语法错误</li>
<li><code>401 Unauthorized</code> 权限未认证</li>
<li><code>403 Forbidden</code> 禁止访问</li>
<li><code>404 Not Found</code> 资源未找到</li>
</ul>
</li>
<li><p>5xx</p>
<p>  服务器端错误</p>
</li>
</ul>
<h1 id="MIME-媒体类型"><a href="#MIME-媒体类型" class="headerlink" title="MIME 媒体类型"></a>MIME 媒体类型</h1><ul>
<li>MIME 类型就是告诉浏览器用什么方式来处理这个数据</li>
<li>MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条杠来分隔，如 <code>text/html</code></li>
<li>MIME 类型在 HTTP 协议中表现为 Request Header 或者 Response Header 中的 <code>Content-Type</code><br><img src="/img/http_mime.png" alt="http_mime" title="http_mime.png"></li>
</ul>
<p>更多类型: <a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">http://tool.oschina.net/commons</a></p>
<h1 id="http-模块-http-模块主要用于搭建-HTTP-服务"><a href="#http-模块-http-模块主要用于搭建-HTTP-服务" class="headerlink" title="http 模块(http 模块主要用于搭建 HTTP 服务)"></a>http 模块(http 模块主要用于搭建 HTTP 服务)</h1><h2 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h2><ul>
<li><p>创建 HTTP 服务并<strong>动态响应</strong>当前时间</p>
<p>  <code>server.listen(port,[host],[backlog],[callback])</code></p>
<ul>
<li><code>port</code> 端口</li>
<li><code>host</code>    主机</li>
<li><code>backlog</code>    <strong>等待</strong>中的队列数量，默认值是 511</li>
<li><code>callback</code> server(服务)监听成功(<strong>请求</strong>到来)的时候服务器调用的回调函数</li>
</ul>
</li>
</ul>
<p><img src="/img/http_createServer.png" alt="http_createServer" title="http_createServer.png"></p>
<ul>
<li><p>将上面这几行代码保存成 app.js，然后用 node 调用这个文件，服务器就开始运行了</p>
<p>  <code>$ node app.js</code></p>
</li>
<li><p>命令行窗口将显示一行提示: “Server running on port 8080.”<br>打开浏览器，访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 网页显示: 2015-12-23 18:07:00</p>
</li>
</ul>
<blockquote>
<p>当通过 webstorm 开启了一个服务(server)之后，没有关闭服务就退出了，这时就没有 Terminal 那个红色方块的停止按钮了，但是可以通过在 任务管理器 的进程中输入 ‘n’来找到 node.exe 进程，右键”结束进程”即可</p>
</blockquote>
<h2 id="响应头信息"><a href="#响应头信息" class="headerlink" title="响应头信息"></a>响应头信息</h2><p><code>response.writeHead(statusCode,[reasonPhrase],[headers])</code></p>
<ul>
<li><p><code>statusCode</code></p>
<p>  <strong>状态码</strong></p>
</li>
<li><p><code>reasonPhrase</code></p>
<p>  状态码<strong>描述</strong>信息</p>
</li>
<li><p><code>headers</code></p>
<p>  响应头对象</p>
<ul>
<li>content-type <strong>内容类型</strong>    </li>
<li>location <strong>重定向</strong>到的URL地址</li>
<li>content-disposition    下载的<strong>文件名</strong></li>
<li>content-length 响应内容的<strong>字节数</strong></li>
<li>set-cookie 写入客户端<strong>cookie</strong></li>
<li>content-encoding 响应内容的<strong>编码</strong>方式</li>
<li>Cache-Control <strong>缓存</strong></li>
<li>Expires 指定缓存<strong>过期时间</strong></li>
<li>Etag 服务器响应<strong>内容没有发生变化</strong>时不重新下载数据</li>
<li>connection 默认是 <code>keep-alive</code> <strong>保持连接</strong>，想断开连接用 <code>close</code></li>
</ul>
</li>
</ul>
<h2 id="设置响应头"><a href="#设置响应头" class="headerlink" title="设置响应头"></a>设置响应头</h2><ul>
<li><p><code>setHeader</code> 方法可以单独设置响应头</p>
<pre><code>response,setHeader(name,value);
</code></pre></li>
<li><p>如果多个响应头的话可以使用数组</p>
<pre><code>response,setHeader(&quot;Set-cookie&quot;,[&quot;name=newlife&quot;,&quot;age=23&quot;]);
</code></pre></li>
</ul>
<h2 id="其他响应设置"><a href="#其他响应设置" class="headerlink" title="其他响应设置"></a>其他响应设置</h2><ul>
<li><code>getHeader</code> <strong>获取</strong>响应头</li>
<li><code>removeHeader</code> <strong>移除</strong>响应头</li>
<li><code>headerSent</code> 响应头是否<strong>已经发送</strong></li>
<li><code>sendData</code> 是否发送<em>响应时间**</em></li>
<li><code>statusCode</code> 设置<strong>响应码</strong></li>
</ul>
<h2 id="使用-url-模块处理-url"><a href="#使用-url-模块处理-url" class="headerlink" title="使用 url 模块处理 url"></a>使用 <code>url</code> 模块处理 <code>url</code></h2><p><code>var url = require(&quot;url&quot;);</code><br><code>var urlObj = url.parse(&quot;原始的url&quot;);</code></p>
<p><code>urlObj</code> 的属性</p>
<ul>
<li><p>href</p>
<p>  被转换的<strong>原URL</strong>字符串</p>
</li>
<li><p>protocal</p>
<p>  客户端请求时的<strong>协议</strong></p>
</li>
<li><p>slashes</p>
<p>  在协议与路径中间是否使用<strong>//</strong>分隔符</p>
</li>
<li><p>host</p>
<p>  字符串中完整的<strong>地址及端口号</strong>，可能为IP也可能为主机名</p>
</li>
<li><p>auth</p>
<p>  <strong>认证</strong>部分</p>
</li>
<li><p>hostname</p>
<p>  <strong>主机名或IP</strong></p>
</li>
<li><p>port</p>
<p>  <strong>端口</strong>号</p>
</li>
<li><p>pathname</p>
<p>  <strong>路径</strong>不包含查询字符串</p>
</li>
<li><p>query</p>
<p>  不包含起始字符<code>?</code>的<strong>查询字符串</strong>，或根据该查询字符串转换而成的对象(由 parse 方法的第二个参数决定，true 就会转成对象)</p>
<pre><code>var url = require(&quot;url&quot;);
var str = &quot;http://192.168.155.1:80/index.html?name=zhufeng&amp;age=7#bbs&quot;;
console.log(url.parse(str));

/*
 Url {
 protocol: &apos;http:&apos;,传输协议
 slashes: true,
 auth: null,
 host: &apos;192.168.155.1:80&apos;,域名+端口号
 port: null,端口号
 hostname: &apos;192.168.155.1&apos;,域名(IP)
 hash: &apos;#bbs&apos;,哈希值
 search: &apos;?name=zhufeng&amp;age=7&apos;,?+传递进来的数据
 query: &apos;name=zhufeng&amp;age=7&apos;,传递进来的数据（不加？）
 pathname: &apos;/index.html&apos;,请求文件的路径及名称
 path: &apos;/index.html?name=zhufeng&amp;age=7&apos;,路径名称+传递的数据
 href: &apos;http://192.168.155.1/index.html?name=zhufeng&amp;age=7&apos; 初始地址（包含所有）
 }
 */

console.log(url.parse(str, true));//增加true后，query中存储的是经过处理解析后的结果：把传递进来的多组数据以键值对的方式进行存储
/*
 ...
 query: {name：&apos;zhufeng&apos;，age：&apos;7&apos;},
 ...
 **/
</code></pre></li>
</ul>
<h2 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h2><p><code>querystring</code> 用来对查询字符串进行转换</p>
<pre><code>var queryObj = querystring.parse(str,[sep],[eq],[options]); //字符串转对象
var queryStr = querystring.stringify(obj,[sep],[eq]); //对象转字符串
</code></pre><ul>
<li><p><code>str</code></p>
<p>  需要被转换的<strong>查询字符串</strong></p>
</li>
<li><p><code>sep</code></p>
<p>  查询字符串中的<strong>分隔</strong>字符，默认为 <code>&amp;</code></p>
</li>
<li><p><code>eq</code></p>
<p>  查询字符串中的<strong>分配</strong>字符，默认参数为 <code>=</code></p>
</li>
<li><p><code>options</code></p>
<p>  为对象参数，可以指定 maxKeys 属性指明转换后的<strong>属性个数</strong>，0 为不限定</p>
</li>
</ul>
<h2 id="写入请求并发送请求"><a href="#写入请求并发送请求" class="headerlink" title="写入请求并发送请求"></a>写入请求并发送请求</h2><ul>
<li><p><code>write</code> 方法向目标服务器<strong>发送数据</strong>，write 方法可以多次调用</p>
<pre><code>request.write(chunk,[encoding]);
</code></pre><ul>
<li><p>chunk 要发送的<strong>数据</strong>，可以是 <code>Buffer</code> 或 字符串</p>
<blockquote>
<ul>
<li><p>response.write(66);</p>
<p>  会报错： first must be a string or Buffer(只能是这两种，其他的都不行)</p>
</li>
<li><p>在响应头发出以后不能再发送响应头</p>
</li>
</ul>
</blockquote>
</li>
<li>encoding <strong>编码</strong>，不指定时默认是 <code>utf8</code></li>
</ul>
</li>
<li><p><code>end</code> 方法用来<strong>结束</strong>本次请求</p>
<pre><code>request.end(chunk,[encoding]);
</code></pre></li>
</ul>
<h2 id="读取静态资源文件并返回"><a href="#读取静态资源文件并返回" class="headerlink" title="读取静态资源文件并返回"></a>读取静态资源文件并返回</h2><p><img src="/img/http_file.png" alt="http_file" title="http_file.png"></p>
<h2 id="根据不同的请求进行不同的响应-路由"><a href="#根据不同的请求进行不同的响应-路由" class="headerlink" title="根据不同的请求进行不同的响应(路由)"></a>根据不同的请求进行不同的响应(路由)</h2><p><img src="/img/http_router.png" alt="http_router" title="http_router.png"></p>
<h2 id="处理-POST-请求"><a href="#处理-POST-请求" class="headerlink" title="处理 POST 请求"></a>处理 <code>POST</code> 请求</h2><ul>
<li>当客户端采用 POST 发送数据时，服务器端可以监听<code>request</code>对象的<code>data</code>和<code>end</code>两个事件<br><img src="/img/http_post.png" alt="http_post" title="http_post.png"></li>
<li><code>data</code>事件会在数据接收过程中，<strong>每收到一段数据</strong>就触发一次，接收到的数据被传入回调函数</li>
<li><code>end</code>事件则是在<strong>所有数据</strong>接收完成后触发</li>
</ul>
<h1 id="创建-http-客户端"><a href="#创建-http-客户端" class="headerlink" title="创建 http 客户端"></a>创建 http 客户端</h1><p><code>request</code> 方法可以向其他网站请求数据</p>
<ul>
<li><p>options</p>
<ul>
<li><p>host </p>
<p>  <strong>域名</strong>或目标主机IP</p>
</li>
<li><p>hostname </p>
<p>  <strong>域名</strong>或目标主机，优先级比 host 高</p>
</li>
<li><p>port </p>
<p>  <strong>端口</strong>号</p>
</li>
<li><p>method </p>
<p>  请求<strong>方法</strong></p>
</li>
<li><p>path</p>
<p>  请求的<strong>路径</strong>，默认为 <code>/</code></p>
</li>
<li><p>headers</p>
<p>  客户端请求<strong>头对象</strong></p>
</li>
<li><p>auth</p>
<p>  <strong>认证</strong>信息，如 “username:password”</p>
</li>
</ul>
</li>
<li>callback = function(response) {}<br>当<strong>获取</strong>到目标网站所返回的<strong>响应流</strong>时调用的回调函数<ul>
<li><code>response</code> 是一个 http.IncomingMessage 对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>方法说明及示例：<br><a href="https://www.cnblogs.com/liyinghao/p/6180591.html" target="_blank" rel="noopener">https://www.cnblogs.com/liyinghao/p/6180591.html</a></p>
</blockquote>
<p>引用说明</p>
<blockquote>
<p>本文资料来源于<strong>珠峰培训</strong><br>链接: <a href="http://www.zhufengpeixun.cn" target="_blank" rel="noopener">http://www.zhufengpeixun.cn</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/11/Node-js模块之Buffer与文件操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/11/Node-js模块之Buffer与文件操作/" itemprop="url">Node.js模块之Buffer与文件操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-11T22:49:30+08:00">
                2017-12-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="模块化的原理"><a href="#模块化的原理" class="headerlink" title="模块化的原理"></a>模块化的原理</h2><pre><code>// 模块化的原理：
function t(__filename, __dirname, module, require) {
    var exports = {};
    ///....
    console.log(__filename);
    ///----------
    return exports;
}
</code></pre><h2 id="模块的分类"><a href="#模块的分类" class="headerlink" title="模块的分类"></a>模块的分类</h2><ul>
<li><em>核心</em>(内置)模块</li>
<li><em>文件</em>模块<ul>
<li>后缀名为.js的文件</li>
<li>后缀名为.json 的JSON文件</li>
<li>后缀名为.node 的经过编译后的二进制模块文件</li>
</ul>
</li>
<li><em>第三方</em>模块</li>
</ul>
<h2 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块"></a>文件模块</h2><h3 id="js-模块"><a href="#js-模块" class="headerlink" title="js 模块"></a>js 模块</h3><ul>
<li>使用exports对象导出<strong>成员</strong></li>
<li>模块定义为<strong>类</strong></li>
<li>定义<strong>类变量</strong></li>
</ul>
<h3 id="json-模块"><a href="#json-模块" class="headerlink" title="json 模块"></a>json 模块</h3><ul>
<li>fs读入内存，并且转化成json对象</li>
</ul>
<h3 id="二进制模块"><a href="#二进制模块" class="headerlink" title="二进制模块"></a>二进制模块</h3><ul>
<li>node编译后的二进制文件 不需要再编译，可以直接使用</li>
</ul>
<h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><p><img src="http://7xjf2l.com2.z0.glb.qiniucdn.com/lookmodule.jpg" class="img-responsive"></p>
<h2 id="查找文件模块"><a href="#查找文件模块" class="headerlink" title="查找文件模块"></a>查找文件模块</h2><h3 id="当没有以’-‘或者’-‘来指向一个文件时，这个模块要么是核心模块，要么就是从node-modules文件夹加载的"><a href="#当没有以’-‘或者’-‘来指向一个文件时，这个模块要么是核心模块，要么就是从node-modules文件夹加载的" class="headerlink" title="当没有以’/‘或者’./‘来指向一个文件时，这个模块要么是核心模块，要么就是从node_modules文件夹加载的"></a>当没有以’/‘或者’./‘来指向一个文件时，这个模块要么是<strong>核心模块</strong>，要么就是从<strong>node_modules</strong>文件夹加载的</h3><p><img src="http://7xjf2l.com2.z0.glb.qiniucdn.com/lookfile.jpg" class="img-responsive"></p>
<ol>
<li><p>从<strong>module.paths</strong>中取出第一个目录开始</p>
</li>
<li><p>直接从目录中查找该文件，存在结束，不存在执行下一条</p>
</li>
<li><p>尝试添加.js .json .node<strong>后缀</strong>查找</p>
</li>
<li><p>尝试将require()的参数作为一个<strong>包</strong>来查找，读取package.json，找到<strong>main</strong>指定的文件，不存在进行 3</p>
</li>
<li><p>查询查找该目录下的<strong>index</strong>(.js/.node)</p>
</li>
<li><p>继续失败查看<strong>下一个</strong>目录，很像<strong>作用域链</strong>查找，<strong>同步阻塞式</strong>的查找，很慢。幸亏有<strong>缓存</strong></p>
</li>
</ol>
<h2 id="module-属性和方法"><a href="#module-属性和方法" class="headerlink" title="module 属性和方法"></a>module 属性和方法</h2><h3 id="module-对象"><a href="#module-对象" class="headerlink" title="module 对象"></a>module 对象</h3><pre><code>Object module {
  id: String, // 模块的ID,模块标识，为该模块文件在系统中的**绝对路径**
  exports: Object, // 该模块的**导出对象**
  parent: Object | undefined, // 引用该模块的**父模块**,即调用当前模块的模块对象
  filename: String | null, // 模块文件名,最终解析的文件名称，模块的**绝对路径**, 与__filename相同。
  loaded: Boolean, // 该模块是否**加载完成**(属性值为布尔值)
  children: Array, // 该模块的引用列表，**子模块**对象，即当前模块require的模块对象
  paths: Array // 模块的**查找路径**(加载路径)
}
</code></pre><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><blockquote>
<p>引入模块</p>
</blockquote>
<h3 id="引入三种模块的方式："><a href="#引入三种模块的方式：" class="headerlink" title="引入三种模块的方式："></a>引入三种模块的方式：</h3><ol>
<li>内置模块 ——&gt; 指定名字</li>
<li>文件模块 -&gt; 路径</li>
<li>第三方模块 -&gt; 指定名字</li>
</ol>
<h3 id="require-函数"><a href="#require-函数" class="headerlink" title="require 函数"></a>require 函数</h3><pre><code>Function require {
  [Function], // 函数体
  resolve: Function, // 根据模块标识解析模块，使用内部的 require() 机制查询模块的位置,返回绝对路径,此操作只返回解析后的文件名，不会加载该模块
  main: undefined | Object, // 应用的主(main)模块
  extensions: {&apos;.js&apos;:Function, &apos;.json&apos;:Function, &apos;.node&apos;:Function}, // 指示 require 怎样处理特定的文件扩展名(废弃的 )

  例如：把 .sjs 文件当做 .js 文件处理：
  require.extensions[&apos;.sjs&apos;] = require.extensions[&apos;.js&apos;];

  cache: Object // 模块缓存，被引入的模块将被缓存在这个对象中，以模块的绝对路径为key
  delete require.cache[key] // 清除require缓存，其中key为模块的绝对路径
}
</code></pre><h2 id="exports-和-module-exports-的区别"><a href="#exports-和-module-exports-的区别" class="headerlink" title="exports 和 module.exports 的区别"></a>exports 和 module.exports 的区别</h2><p>参考地址:</p>
<blockquote>
<p><a href="http://cnodejs.org/topic/5231a630101e574521e45ef8" target="_blank" rel="noopener">http://cnodejs.org/topic/5231a630101e574521e45ef8</a></p>
<p><a href="http://cnodejs.org/topic/52308842101e574521c16e06" target="_blank" rel="noopener">http://cnodejs.org/topic/52308842101e574521c16e06</a></p>
</blockquote>
<h3 id="先来看一个例子"><a href="#先来看一个例子" class="headerlink" title="先来看一个例子"></a>先来看一个例子</h3><p>test.js</p>
<pre><code>var a = {name: 1};
var b = a;

console.log(a);
console.log(b);

b.name = 2;
console.log(a);
console.log(b);

var b = {name: 3};
console.log(a);
console.log(b);
</code></pre><p>运行 test.js 结果为：</p>
<pre><code>{ name: 1 }
{ name: 1 }
{ name: 2 }
{ name: 2 }
{ name: 2 }
{ name: 3 }
</code></pre><p>解释：a 是一个对象，b 是对 a 的引用，即 a 和 b 指向同一块内存，所以前两个输出一样。当对 b 作修改时，即 a 和 b 指向同一块内存地址的内容发生了改变，所以 a 也会体现出来，所以第三四个输出一样。当 b 被覆盖时，b 指向了一块新的内存，a 还是指向原来的内存，所以最后两个输出不一样</p>
<h3 id="下面说明两者的区别"><a href="#下面说明两者的区别" class="headerlink" title="下面说明两者的区别"></a>下面说明两者的区别</h3><p>每一个node.js执行文件，都自动创建一个module对象，同时，module对象会创建一个叫exports的属性</p>
<ol>
<li>module.exports 初始值为一个空对象 {}</li>
<li>exports 是指向的 module.exports 的引用</li>
<li>require() 返回的是 module.exports 而不是 exports</li>
</ol>
<h4 id="现在我们来看-Node-js-官方文档的截图"><a href="#现在我们来看-Node-js-官方文档的截图" class="headerlink" title="现在我们来看 Node.js 官方文档的截图:"></a>现在我们来看 Node.js 官方文档的截图:</h4><p><img src="/img/exports.png" alt="exports" title="exports.png"></p>
<h4 id="我们经常看到这样的写法："><a href="#我们经常看到这样的写法：" class="headerlink" title="我们经常看到这样的写法："></a>我们经常看到这样的写法：</h4><p><code>exports = module.exports = somethings</code></p>
<p>上面的代码等价于:</p>
<p><code>module.exports = somethings
exports = module.exports</code></p>
<p>原理很简单，即 module.exports 指向新的对象时，exports 断开了与 module.exports 的引用，那么通过 exports = module.exports 让 exports 重新指向 module.exports 即可</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="在-node-js-中通过包来对具有相互依赖关系的模块进行统一管理；一个包就是一个目录"><a href="#在-node-js-中通过包来对具有相互依赖关系的模块进行统一管理；一个包就是一个目录" class="headerlink" title="在 node.js 中通过包来对具有相互依赖关系的模块进行统一管理；一个包就是一个目录"></a>在 node.js 中通过包来对具有<strong>相互依赖</strong>关系的模块进行统一管理；一个包就是一个<strong>目录</strong></h3><ul>
<li>package.json 包描述文件</li>
<li>bin 用于存放可执行二进制文件的目录</li>
<li>lib 用于存放JavaScript代码的目录</li>
<li>doc 用于存放文档(说明文档)的目录</li>
<li>test 用于存放单元测试和其它测试用例的代码</li>
</ul>
<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><pre><code>{
&quot;name&quot;:&quot;包的名称，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。&quot;,
&quot;description&quot;：&quot;包的简要说明。&quot;,
&quot;version&quot;:&quot;符合语义化八本识别规范的版本字符串。&quot;,
&quot;keywords&quot;：&quot;关键字数组，通常用于搜索。&quot;,
&quot;maintainers&quot;:&quot;维护者数组，每个元素要包含name、email（可选）、web（可选）字段。&quot;,
&quot;contributors&quot;：&quot;贡献者数组，格式与maintainers相同。包的作者应该是贡献者数组的第一个元素。&quot;,
&quot;bugs&quot;：&quot;提交bug的地址，可以是网址或者电子邮件地址。&quot;.,
&quot;licenses&quot;:&quot;许可证数组，每个元素要包含type(许可证的名称)和url(链接到许可证文本的地址)字段。&quot;,
&quot;repositories&quot;：&quot;仓库托管地址数组。每个元素要包含type(许可证的名称)和url(链接到许可证文本的地址)字段。&quot;,
&quot;dependencies&quot;:&quot;包的依赖，一个关联数组，由包名称和版本组成。&quot;
}
</code></pre><h2 id="npm-包管理工具"><a href="#npm-包管理工具" class="headerlink" title="npm 包管理工具"></a>npm 包管理工具</h2><ul>
<li>npm <strong>search</strong> gulp 查找包</li>
<li><strong>npmview</strong> gulp 查看包</li>
<li>npm <strong>install</strong> gulp 安装包</li>
<li>npm <strong>install -g</strong> express-generator 全局安装包</li>
<li>npm <strong>root -g</strong> 查看全局安装路径</li>
<li>npm config <strong>set prefix</strong> “d:\global” 修改全局路径</li>
<li><strong>npmlist</strong> 显示当前目录下所有的包</li>
<li><strong>npmlist -g</strong> 显示全局下所有包</li>
<li>npm <strong>uninstall</strong> gulp 卸载本地的包</li>
<li>npm <strong>uninstall</strong> gulp <strong>-g</strong> 卸载全局下的包</li>
<li>npm <strong>update</strong> gulp 更新本地的gulp</li>
<li>npm <strong>update</strong> <strong>-g</strong> gulp 更新全局下的gulp</li>
<li>npm <strong>update</strong> 更新当前目录下所有的包</li>
<li>npm <strong>update -g</strong> 更新全局下所有的包</li>
</ul>
<h2 id="发布一个-包-到-npmjs-org-网站上-项目管理"><a href="#发布一个-包-到-npmjs-org-网站上-项目管理" class="headerlink" title="发布一个 包 到 npmjs.org 网站上(项目管理)"></a>发布一个 <code>包</code> 到 <code>npmjs.org</code> 网站上(项目管理)</h2><ul>
<li><p>初始化项目</p>
<p>  <code>npm init</code></p>
<p>  配置项：<br>  name: 不能有大写字母，不能有中文，而且不能是别人已经注册的名称<br>  …</p>
</li>
<li><p>安装第三方模块(这时安装的模块会自动被加入到package.json文件的依赖[dependencies]字段中去)</p>
<p>  <code>npm install [package name]</code></p>
</li>
<li><p>注册用户</p>
<p>  <code>npm adduser</code> -&gt; 输入用户名、密码和邮箱</p>
</li>
<li><p>发布项目</p>
<p>  <code>npm publish</code></p>
<p>  (如果注册失败的话可能是因为改了镜像地址了，需要改回来：npm config set registry “<a href="http://regidtry.npmjs.org/" target="_blank" rel="noopener">http://regidtry.npmjs.org/</a>“)</p>
</li>
</ul>
<blockquote>
<p>可参考地址：<a href="https://segmentfault.com/a/1190000006250554" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006250554</a></p>
</blockquote>
<h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><h2 id="什么是-Buffer"><a href="#什么是-Buffer" class="headerlink" title="什么是 Buffer"></a>什么是 Buffer</h2><ul>
<li>缓冲区Buffer是暂时存放输入输出数据的一段<strong>内存</strong>。 {:&amp;.moveIn}</li>
<li>JS语言自身只有字符串数据类型，没有<strong>二进制</strong>数据类型，而在处理TCP和文件流的时候，必须要处理二进制数据。</li>
<li>NodeJS提供了一个Buffer对象来提供对二进制数据的操作</li>
<li>是一个表示<strong>固定</strong>内存分配的全局对象，也就是说要放到缓存区中的字节数需要<strong>提前确定</strong></li>
<li>Buffer好比由一个<strong>八位字节</strong>元素(每个元素都是一个字节，并且每个字节为8位)组成的数组，可以有效的在javascript中表示二进制数据</li>
</ul>
<h3 id="什么是字节"><a href="#什么是字节" class="headerlink" title="什么是字节"></a>什么是字节</h3><ul>
<li>字节(Byte)是计算机存储时的一种<em>计量</em>单位，一个字节等于<em>8位(bit)</em>二进制数</li>
<li>字节是通过网络传输信息的单位</li>
<li>一个字节最大值十进制数是255</li>
</ul>
<h3 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h3><ul>
<li>ASCII 码使用指定的7位或者8位二进制数组合来表示128或256种可能的字<br><img src="/img/ascii.png" alt="ascii" title="ascii.png"></li>
</ul>
<h2 id="创建-Buffer"><a href="#创建-Buffer" class="headerlink" title="创建 Buffer"></a>创建 Buffer</h2><ul>
<li>new Buffer(size) // 指定大小</li>
<li>new Buffer(array) // 通过数组来创建</li>
<li>new Buffer(str,[encoding]) // 通过字符串来创建</li>
</ul>
<h2 id="Buffer-操作"><a href="#Buffer-操作" class="headerlink" title="Buffer 操作"></a>Buffer 操作</h2><p>Node.js 中文网地址: <a href="http://nodejs.cn/api/buffer.html" target="_blank" rel="noopener">http://nodejs.cn/api/buffer.html</a></p>
<ul>
<li><p>Buffer和字符串长度</p>
<p>  <code>buf.length</code> 返回 buf 在字节数上分配的内存量</p>
<p>  <code>length</code> 属性表示一个字符串的长度</p>
</li>
<li><p>Buffer和字符串的转换</p>
<p>  Buffer 转字符串</p>
<p>  <code>buf.toString([encoding],[start],[end])</code> 包含 start,不包含 end,默认值:<code>&#39;utf8&#39;</code>,<code>0</code>,<code>buf.length</code></p>
<p>  字符串转 Buffer</p>
<p>  <code>new Buffer(string, [encoding])</code> (废弃的) 使用 <code>Buffer.from(string, [encoding])</code> 替代</p>
</li>
<li><p>Buffer和数值对象转换</p>
<p>  <code>buf.readInt8(offset, [noAssert])</code></p>
<p>  从 buf 中指定的 offset 读取一个有符号的8位整数值</p>
<ul>
<li>offset <code>&lt;integer&gt;</code> 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 1</li>
<li>noAssert <code>&lt;boolean&gt;</code> 是否跳过 offset 检验？默认: false</li>
<li>返回: <code>&lt;integer&gt;</code></li>
<li>设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的</li>
<li><p>还有其他的转换成其他数值格式的方法…</p>
<p><code>buf.writeInt8(value, offset[, noAssert])</code></p>
<p>写入 value 到 buf 中指定的 offset 位置 value 应当是一个有效的有符号的8位整数。 当 value * 不是一个有符号的8位整数时，反应是不确定的</p>
</li>
<li>value <code>&lt;integer&gt;</code> 要写入 buf 的数值</li>
<li>offset <code>&lt;integer&gt;</code> 开始写入前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 1</li>
<li>noAssert <code>&lt;boolean&gt;</code> 是否跳过 value 和 offset 检验？默认: false</li>
<li>返回: <code>&lt;integer&gt;</code> offset 加上写入的字节数</li>
</ul>
</li>
<li><p>Buffer 和 JSON 对象转换</p>
<p>  <code>http://nodejs.cn/api/buffer.html</code></p>
<ul>
<li><p>返回 buf 的 JSON 格式。 当使用<code>JSON.stringify()</code>字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该函数</p>
</li>
<li><p>返回: <code>&lt;Object&gt;</code></p>
</li>
</ul>
</li>
<li><p>复制 Buffer</p>
<pre><code>`buf.copy(targetBuffer,[targetStart],[sourceStart],[sourceEnd]);`
</code></pre></li>
</ul>
<h2 id="Buffer-常用方法"><a href="#Buffer-常用方法" class="headerlink" title="Buffer 常用方法"></a>Buffer 常用方法</h2><ul>
<li>合并 Buffer: <code>Buffer.concat([buf1,buf2],length)</code></li>
<li>复制 Buffer: <code>buf.copy(targetBuffer,[targetStart],[sourceStart],[sourceEnd]);</code></li>
<li>判断是否是 Buffer: <code>Buffer.isBuffer</code></li>
<li>获取字节长度: <code>Buffer.byteLength</code></li>
<li>检查字符编码:<code>Buffer.isEncoding(encoding)</code>(如果 encoding 是一个支持的字符编码则返回 true，否则返回 false)</li>
</ul>
<h1 id="file-system-文件系统"><a href="#file-system-文件系统" class="headerlink" title="file system(文件系统)"></a>file system(文件系统)</h1><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><h3 id="异步读取"><a href="#异步读取" class="headerlink" title="异步读取"></a>异步读取</h3><pre><code>/**
 * 1.异步方法需要把回调函数传入
 * 2. 回调函数会在同步方法执行完毕之后才执行异步回调
 * 3.异步方法不能阻塞主线程，不会影响后续代码的执行
 */
</code></pre><p><code>readFile</code></p>
<h3 id="同步读取"><a href="#同步读取" class="headerlink" title="同步读取"></a>同步读取</h3><pre><code>/**
 * 1. 每一个同步方法和异步方法都是成对出现的
 * 2. 同步方法会阻塞主线程的执行，在数据没有返回之间不能执行后续代码
 * 3. 它不需要传递回调函数，通过函数返回值接收结果
 */
</code></pre><p><code>readFileSync</code></p>
<blockquote>
<p>try catch只能捕获同步方法的异常，异步方法的异常无法捕获，异步异常只能通过方法内部的回调函数来捕获</p>
</blockquote>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><h3 id="异步写入"><a href="#异步写入" class="headerlink" title="异步写入"></a>异步写入</h3><p><code>writeFile</code></p>
<pre><code>/**
 * 异步操作
 * flag 是表示要对此文件做何种类型的操作
 *   w 清空并写入
 *   a 在原有基础上追加
 */
fs.writeFile(&apos;./write.txt&apos;, &apos;node读写&apos;, {flag: &apos;a&apos;}, function (err) {
    if (err) {
        console.log(err);
    }
});

fs.appendFile(&apos;./write.txt&apos;,&apos;node&apos;);
</code></pre><h3 id="同步写入"><a href="#同步写入" class="headerlink" title="同步写入"></a>同步写入</h3><p><code>writeFileSync</code></p>
<blockquote>
<p>回调里面的 err data 是由fs.readFile决定的</p>
</blockquote>
<h3 id="运用-fs-的读取和写入方法实现-copy-功能"><a href="#运用-fs-的读取和写入方法实现-copy-功能" class="headerlink" title="运用 fs 的读取和写入方法实现 copy 功能"></a>运用 fs 的<code>读取</code>和<code>写入</code>方法实现 copy 功能</h3><blockquote>
<p>（注意点：当数据内容本身是 utf8 编码时才能在方法中加上 “utf8” 编码，否则就会转换错误，例如图片就是二进制数据，使用 utf8 编码不能正常处理）</p>
</blockquote>
<pre><code>/**
 * 1. 把src里的文件内容，写入到target文件里
 * 2.写入时要先清空再写入
 */

&apos;use strict&apos;;

var fs = require(&apos;fs&apos;);

function copy(src, target) {
    fs.readFile(src, function (err, data) {
        fs.writeFile(target, data, function (err) {
            console.log(&quot;copy success from &quot; + src + &quot;to &quot; + target);
        });
    });
}
copy(&quot;./atm.jpg&quot;, &apos;./atm2.jpg&apos;);

copy(&apos;./name.txt&apos;, &apos;./name.bak.txt&apos;);
</code></pre><h4 id="回调函数的嵌套"><a href="#回调函数的嵌套" class="headerlink" title="回调函数的嵌套"></a>回调函数的嵌套</h4><pre><code>//1.回调函数嵌套实现多个异步操作完成之后执行的回调
//1. 需要的时间长，m+n
//2. 代码可读性非常差
fs.readFile(&apos;./name.txt&apos;, &apos;utf8&apos;, function (err, name) {
    fs.readFile(&apos;./age.txt&apos;, &apos;utf8&apos;, function (err, age) {
        console.log(name, age);
    });
});
</code></pre><h1 id="操作目录"><a href="#操作目录" class="headerlink" title="操作目录"></a>操作目录</h1><ol>
<li><p>创建目录</p>
<blockquote>
<p>创建目录 的时候要求父目录必须存在</p>
</blockquote>
<pre><code>fs.mkdir(&apos;test/t1/t2&apos;, function (err) {
    if (err) {
        console.log(err);
        console.log(&apos;目录创建失败&apos;);
    } else {
        console.log(&apos;目录创建成功&apos;);
    }
});
</code></pre></li>
<li><p>读取目录下面所有的文件</p>
<pre><code>fs.readdir(&apos;./book&apos;, function (err, files) {
    console.log(files);
});
</code></pre></li>
<li><p>获取一个文件或目录详情</p>
<pre><code>fs.readdir(&apos;./book&apos;, function (err, files) {
    //循环文件列表
    files.forEach(function (file) {
        //获取文件的详情
        fs.stat(&apos;./book/&apos; + file, function (err, state) {
            console.log(state.isDirectory());//是否是目录
            console.log(state.isFile());//是否是文件
            console.log(state.size);
            // state是一个对象，里面有许多字段；其中 atime,mtime,birthtime,ctime都是 Date 对象的实例
            // 但是atime表示最后一次读取文件的时间，mtime(modify)表示最后一次修改文件的时间（当打开文件最后结果却没有变化时时间是不会变的），
birthtime表示文件创建时间，ctime表示最后一次修改文件的时间（当打开文件结果却没有变化时时间也会变）
        });
    });
});
</code></pre></li>
<li><p>判断一个文件(或文件夹)是否存在</p>
<pre><code>fs.exists(&apos;./book&apos;, function (exists) {
    console.log(exists);
});
</code></pre></li>
</ol>
<h1 id="处理路径"><a href="#处理路径" class="headerlink" title="处理路径"></a>处理路径</h1><pre><code>var path = require(&apos;path&apos;);

//合并 连接路径
console.log(path.join(&apos;book&apos;, &apos;mysql.json&apos;));
//seperator 分隔符
console.log(path.sep);
console.log(__filename);//获取当前模块的绝地路径
console.log(__dirname);//获取 当前模块所在的绝对目录
//获取一个路径里文件的名
console.log(path.basename(&apos;7.path.js&apos;, &apos;.js&apos;));
//获取一个路径里文件的扩展名
console.log(path.extname(&apos;7.path.js&apos;));
//从一个相对路径解析出一个绝对路径
//以应用程序的所在目录为根起
console.log(path.resolve(&apos;book&apos;, &apos;node.json&apos;, &apos;..&apos;, &apos;mysql.json&apos;));
</code></pre><h3 id="path-resolve-绝对路径"><a href="#path-resolve-绝对路径" class="headerlink" title="path.resolve 绝对路径"></a><code>path.resolve</code> 绝对路径</h3><blockquote>
<p>参考链接: <a href="https://www.cnblogs.com/52cik/p/learn-node-path.html" target="_blank" rel="noopener">https://www.cnblogs.com/52cik/p/learn-node-path.html</a></p>
</blockquote>
<p>这个绝对路径操作，跟上面的不太一样，如果你懂命令行 cd 命令，那就秒懂了，否则需要花点时间多跑几个例子才能理解。这次直接上官方例子</p>
<pre><code>path.resolve(&apos;foo/bar&apos;, &apos;/tmp/file/&apos;, &apos;..&apos;, &apos;a/../subfile&apos;);
// 返回 /tmp/subfile
</code></pre><p>相当于命令行下的</p>
<pre><code>cd foo/bar
cd /tmp/file/
cd ..
cd a/../subfile
pwd
</code></pre><p>他的解析不是在是简单的拼接关系，而是类似 cd 命令的解析了</p>
<h1 id="webstorm-的设置及一些使用技巧"><a href="#webstorm-的设置及一些使用技巧" class="headerlink" title="webstorm 的设置及一些使用技巧"></a>webstorm 的设置及一些使用技巧</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li><p>配置字体和大小</p>
<p>  <code>File</code> -&gt; <code>Settings</code> -&gt; <code>Editor</code> -&gt; <code>Colors &amp; Fonts</code> -&gt; <code>Font</code></p>
</li>
<li><p>配置 智能提示<br><img src="/img/code_assistant.png" alt="code_assistant" title="code_assistant.png">  </p>
<blockquote>
<p>此外，还需要点击 <code>enable</code> 按钮来允许，以及点击 <code>Usage scope</code> 来勾选你所需要的提示类型</p>
</blockquote>
</li>
<li><p>乱码问题：</p>
<pre><code>1. 在 Settings 中搜索 File Encoding 来找到编码：
2. IDE Encoding-&gt;针对于整个 IDE,就是所有的项目
3. Project Encoding-&gt;针对当前项目
4. 而且还要注意当前文件的编码-&gt;代码编码区右下角显示的编码是否为你所需要的
</code></pre></li>
<li><p>查看node相关方法的源码实现：</p>
<pre><code>ctrl+鼠标左键点击，即可进入node源码
</code></pre></li>
<li><p>编辑文件的模板：</p>
<pre><code>1. 任意一个目录右键-&gt;Edit File Template,即可进入编辑模板页面
2. File页面-&gt;点击&quot;+&quot;新建模板-&gt;&quot;Name&quot;:名称;&quot;Extension&quot;:扩展名-&gt;Apply-&gt;Ok
3. 中间空白区域可以写模板，直接写就行，记得最后也要Apply-&gt;Ok
</code></pre></li>
<li><p>当卸载了原来使用 node 安装程序安装的 node,而使用 nvm 来重新安装 node 时，这时你的 webstorm 环境就需要重新配置 node 环境了，而且在配置好之后如果执行 node 命令错误的话，先退出然后再打开，应该就能使用 node 命令了(前提是你在电脑的任意盘下执行node命令都是正确的，否则就是node的环境变量配有配置正确)</p>
</li>
<li><p>临时解决项目运行时总是报找不到模块的错误 -&gt; 在当前项目位置安装报错中指明的找不到的模块</p>
</li>
<li><p>当在 webstorm 调试时遇到 js 文件的路径问题，可以先将对应的 js 文件整个拷贝到 html 页面中去调试功能，最后再来琢磨路径问题</p>
</li>
</ul>
<blockquote>
<p>本文所用资料来自于<strong>珠峰培训</strong>和一些网上摘录(一些引用没有一一给出地址，望原作者见谅)</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/10/markdown-grammar-markdown语法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/10/markdown-grammar-markdown语法/" itemprop="url">markdown_grammar(markdown语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-10T16:36:36+08:00">
                2017-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/标记语言/" itemprop="url" rel="index">
                    <span itemprop="name">标记语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>教程网址：<a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">http://wowubuntu.com/markdown/</a></p>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><pre><code># 这是 H1
## 这是 H2
### 这是 H3
#### 这是 H4
##### 这是 H5
###### 这是 H6
</code></pre><h1 id="这是-H1"><a href="#这是-H1" class="headerlink" title="这是 H1"></a>这是 H1</h1><h2 id="这是-H2"><a href="#这是-H2" class="headerlink" title="这是 H2"></a>这是 H2</h2><h3 id="这是-H3"><a href="#这是-H3" class="headerlink" title="这是 H3"></a>这是 H3</h3><h4 id="这是-H4"><a href="#这是-H4" class="headerlink" title="这是 H4"></a>这是 H4</h4><h5 id="这是-H5"><a href="#这是-H5" class="headerlink" title="这是 H5"></a>这是 H5</h5><h6 id="这是-H6"><a href="#这是-H6" class="headerlink" title="这是 H6"></a>这是 H6</h6><h1 id="区块引用-Blockquotes"><a href="#区块引用-Blockquotes" class="headerlink" title="区块引用 Blockquotes"></a>区块引用 Blockquotes</h1><pre><code>&gt; This is a blockquote

&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&gt; This is the first level of quoting.
&gt;
&gt; &gt; This is nested blockquote.
&gt;
&gt; Back to the first level.
</code></pre><blockquote>
<p>This is a blockquote</p>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
<h3 id="引用的区块内也可以使用其他的-Markdown-语法，包括标题、列表、代码区块等"><a href="#引用的区块内也可以使用其他的-Markdown-语法，包括标题、列表、代码区块等" class="headerlink" title="引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等"></a>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等</h3><pre><code>&gt; ## 这是一个标题
&gt; 1. 这是第一行列表项
&gt; 2. 这是第二行列表项
&gt;
&gt; 给出一些例子代码：
&gt; 
&gt; return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre><blockquote>
<h2 id="这是一个标题"><a href="#这是一个标题" class="headerlink" title="这是一个标题"></a>这是一个标题</h2><ol>
<li>这是第一行列表项</li>
<li>这是第二行列表项</li>
</ol>
<p>给出一些例子代码：</p>
<p>return shell_exec(“echo $input | $markdown_script”);</p>
</blockquote>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h3 id="无序列表使用星号、加号或是减号作为列表标记"><a href="#无序列表使用星号、加号或是减号作为列表标记" class="headerlink" title="无序列表使用星号、加号或是减号作为列表标记"></a>无序列表使用星号、加号或是减号作为列表标记</h3><h4 id="无序列表："><a href="#无序列表：" class="headerlink" title="无序列表："></a>无序列表：</h4><h5 id="列表1"><a href="#列表1" class="headerlink" title="列表1"></a>列表1</h5><pre><code>* Red
* Green
* Blue
</code></pre><ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<h5 id="列表2"><a href="#列表2" class="headerlink" title="列表2"></a>列表2</h5><pre><code>+ Red
+ Green
+ Blue
</code></pre><ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<h5 id="列表3"><a href="#列表3" class="headerlink" title="列表3"></a>列表3</h5><pre><code>- Red
- Green
- Blue
</code></pre><ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<h4 id="有序列表-很重要的一点是，你在列表标记上使用的数字并不会影响输出的-HTML-结果"><a href="#有序列表-很重要的一点是，你在列表标记上使用的数字并不会影响输出的-HTML-结果" class="headerlink" title="有序列表(很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果)"></a>有序列表(很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果)</h4><h5 id="列表1-1"><a href="#列表1-1" class="headerlink" title="列表1"></a>列表1</h5><pre><code>1. Red
2. Green
3. Blue
</code></pre><ol>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ol>
<h5 id="列表2-1"><a href="#列表2-1" class="headerlink" title="列表2"></a>列表2</h5><pre><code>1. Red
2. Green
3. Blue
</code></pre><ol>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ol>
<h5 id="列表3-1"><a href="#列表3-1" class="headerlink" title="列表3"></a>列表3</h5><pre><code>3. Red
4. Green
5. Blue
</code></pre><ol>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ol>
<h4 id="列表项缩进"><a href="#列表项缩进" class="headerlink" title="列表项缩进"></a>列表项缩进</h4><h5 id="未缩进格式"><a href="#未缩进格式" class="headerlink" title="未缩进格式"></a>未缩进格式</h5><pre><code>* Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
</code></pre><ul>
<li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,<br>viverra nec, fringilla in, laoreet vitae, risus.</li>
</ul>
<h5 id="使用-amp-ensp-缩进"><a href="#使用-amp-ensp-缩进" class="headerlink" title="使用&amp;ensp;缩进"></a>使用<code>&amp;ensp;</code>缩进</h5><pre><code>* &amp;ensp;Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
</code></pre><ul>
<li>&ensp;Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,<br>viverra nec, fringilla in, laoreet vitae, risus.</li>
</ul>
<h5 id="使用两个-amp-ensp-缩进"><a href="#使用两个-amp-ensp-缩进" class="headerlink" title="使用两个&amp;ensp;缩进"></a>使用两个<code>&amp;ensp;</code>缩进</h5><pre><code>* &amp;ensp;&amp;ensp;Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
</code></pre><ul>
<li>&ensp;&ensp;Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,<br>viverra nec, fringilla in, laoreet vitae, risus.</li>
</ul>
<h5 id="使用-amp-emsp-缩进"><a href="#使用-amp-emsp-缩进" class="headerlink" title="使用&amp;emsp;缩进"></a>使用<code>&amp;emsp;</code>缩进</h5><pre><code>* &amp;emsp;Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
</code></pre><ul>
<li>&emsp;Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,<br>viverra nec, fringilla in, laoreet vitae, risus.</li>
</ul>
<h5 id="使用-amp-nbsp-缩进"><a href="#使用-amp-nbsp-缩进" class="headerlink" title="使用&amp;nbsp;缩进"></a>使用<code>&amp;nbsp;</code>缩进</h5><pre><code>* &amp;nbsp;Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
</code></pre><ul>
<li>&nbsp;Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,<br>viverra nec, fringilla in, laoreet vitae, risus.</li>
</ul>
<h6 id="输入法切换到全角，双击空格键缩进"><a href="#输入法切换到全角，双击空格键缩进" class="headerlink" title="输入法切换到全角，双击空格键缩进"></a>输入法切换到全角，双击空格键缩进</h6><pre><code>* 　　Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
</code></pre><ul>
<li>　　Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,<br>viverra nec, fringilla in, laoreet vitae, risus.</li>
</ul>
<h6 id="列表项包含多个段落，每个项目下的段落都必须缩进-4-个空格或是-1-个制表符"><a href="#列表项包含多个段落，每个项目下的段落都必须缩进-4-个空格或是-1-个制表符" class="headerlink" title="列表项包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符"></a>列表项包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符</h6><pre><code>1. This is a list item with two paragraphs. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit. Aliquam hendrerit
mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
sit amet velit.
</code></pre><ol>
<li><p>This is a list item with two paragraphs. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br>mi posuere lectus.</p>
<p> Vestibulum enim wisi, viverra nec, fringilla in, laoreet<br>vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>sit amet velit.</p>
</li>
</ol>
<h6 id="如果要在列表项目内放进引用，那-gt-就需要缩进"><a href="#如果要在列表项目内放进引用，那-gt-就需要缩进" class="headerlink" title="如果要在列表项目内放进引用，那 &gt; 就需要缩进"></a>如果要在列表项目内放进引用，那 &gt; 就需要缩进</h6><pre><code>* A list item with a blockquote:
    &gt; This is a blockquote
    &gt; inside a list item.
</code></pre><ul>
<li>A list item with a blockquote:<blockquote>
<p>This is a blockquote<br>inside a list item.</p>
</blockquote>
</li>
</ul>
<h6 id="如果要放代码区块的话，该区块就需要缩进两次，也就是-8-个空格或是-2-个制表符"><a href="#如果要放代码区块的话，该区块就需要缩进两次，也就是-8-个空格或是-2-个制表符" class="headerlink" title="如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符"></a>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符</h6><pre><code>* 一列表项包含一个列表区块：

        &lt;代码写在这&gt;
</code></pre><ul>
<li><p>一列表项包含一个列表区块：</p>
<pre><code>&lt;代码写在这&gt;
</code></pre></li>
</ul>
<h6 id="在行首出现数字-句点-空白"><a href="#在行首出现数字-句点-空白" class="headerlink" title="在行首出现数字-句点-空白"></a>在行首出现数字-句点-空白</h6><pre><code>1986. What a great season.
</code></pre><ol>
<li>What a great season.</li>
</ol>
<h6 id="避免这样的状况，你可以在句点前面加上反斜杠"><a href="#避免这样的状况，你可以在句点前面加上反斜杠" class="headerlink" title="避免这样的状况，你可以在句点前面加上反斜杠"></a>避免这样的状况，你可以在句点前面加上反斜杠</h6><pre><code>1986\. What a great season.
</code></pre><p>1986. What a great season.</p>
<h1 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h1><pre><code>这是一个普通段落：

    这是一个代码区块
Here is an example of AppleScript:

    tell application &quot;Foo&quot;
        beep
    end tell
</code></pre><p>这是一个普通段落：</p>
<pre><code>这是一个代码区块
</code></pre><p>Here is an example of AppleScript:</p>
<pre><code>tell application &quot;Foo&quot;
    beep
end tell
</code></pre><h1 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h1><h3 id="你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线"><a href="#你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线" class="headerlink" title="你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线"></a>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线</h3><pre><code>* * *

***

* *  *

****

---

___
</code></pre><hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<h1 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h1><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="两种形式的链接语法：-行内式和参考式两种形式"><a href="#两种形式的链接语法：-行内式和参考式两种形式" class="headerlink" title="两种形式的链接语法： 行内式和参考式两种形式"></a>两种形式的链接语法： 行内式和参考式两种形式</h4><h5 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h5><pre><code>[百度](http://www.baidu.com/ &quot;title&quot;)
</code></pre><p><a href="http://www.baidu.com/" title="title" target="_blank" rel="noopener">百度</a></p>
<h5 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h5><pre><code>[百度][0]
[0]: http://www.baidu.com/
</code></pre><p><a href="http://www.baidu.com/" target="_blank" rel="noopener">百度</a></p>
<h6 id="下面这三种链接的定义都是相同"><a href="#下面这三种链接的定义都是相同" class="headerlink" title="下面这三种链接的定义都是相同"></a>下面这三种链接的定义都是相同</h6><pre><code>[newlife&apos;sBlog][Iunderstood]
[Iunderstood]: http://Iunderstood.github.io/ &apos;newlife&apos;sBlog&apos;
[Iunderstood]: http://Iunderstood.github.io/ &quot;newlife&apos;sBlog&quot;
[Iunderstood]: http://Iunderstood.github.io/ (newlife&apos;sBlog)
[Iunderstood]: &lt;http://Iunderstood.github.io/&gt; &quot;newlife&apos;sBlog&quot;
[Iunderstood]: http://Iunderstood.github.io/ 
&quot;newlife&apos;sBlog&quot;
</code></pre><p><a href="http://Iunderstood.github.io/" title="newlife&#39;sBlog" target="_blank" rel="noopener">newlife’sBlog</a></p>
<h6 id="链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的"><a href="#链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的" class="headerlink" title="链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的"></a>链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的</h6><pre><code>[小米][m]

[小米][M]
[m]: http://www.mi.com/
</code></pre><p><a href="http://www.mi.com/" target="_blank" rel="noopener">小米</a></p>
<p><a href="http://www.mi.com/" target="_blank" rel="noopener">小米</a></p>
<h6 id="隐式链接标记功能-链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号"><a href="#隐式链接标记功能-链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号" class="headerlink" title="隐式链接标记功能:链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号"></a>隐式链接标记功能:链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号</h6><pre><code>[baidu][]
[baidu]: http://www.baidu.com/
</code></pre><p><a href="http://www.baidu.com/" target="_blank" rel="noopener">baidu</a></p>
<h6 id="由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词"><a href="#由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词" class="headerlink" title="由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词"></a>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词</h6><pre><code>[baidu website][]
[baidu website]: http://www.baidu.com/
</code></pre><p><a href="http://www.baidu.com/" target="_blank" rel="noopener">baidu website</a></p>
<h6 id="链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样"><a href="#链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样" class="headerlink" title="链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样"></a>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样</h6><pre><code>下面是一个参考式链接的范例：

I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        &quot;Google&quot;
  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [3]: http://search.msn.com/    &quot;MSN Search&quot;

如果改成用链接名称的方式写：

I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][].

  [google]: http://google.com/        &quot;Google&quot;
  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;

下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：

I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;) than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or [MSN](http://search.msn.com/ &quot;MSN Search&quot;).
</code></pre><p>下面是一个参考式链接的范例：</p>
<p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener">Google</a> than from <a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p>
<p>如果改成用链接名称的方式写：</p>
<p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener">Google</a> than from <a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p>
<p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p>
<p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener">Google</a> than from <a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p>
<h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><h3 id="被-或-包围的字词会被转成用-lt-em-gt-标签包围-斜体-，用两个-或-包起来的话，则会被转成-lt-strong-gt-加粗"><a href="#被-或-包围的字词会被转成用-lt-em-gt-标签包围-斜体-，用两个-或-包起来的话，则会被转成-lt-strong-gt-加粗" class="headerlink" title="被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围(斜体)，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong&gt;(加粗)"></a>被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围(斜体)，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>(加粗)</h3><pre><code>*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
</code></pre><p><em>single asterisks</em></p>
<p><em>single underscores</em></p>
<p><strong>double asterisks</strong></p>
<p><strong>double underscores</strong></p>
<h4 id="如果你的-和-两边都有空白的话，它们就只会被当成普通的符号"><a href="#如果你的-和-两边都有空白的话，它们就只会被当成普通的符号" class="headerlink" title="如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号"></a>如果你的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</h4><p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p>
<pre><code>\*this text is surrounded by literal asterisks\*
</code></pre><p>*this text is surrounded by literal asterisks*</p>
<h1 id="代码-标记一小段行内代码"><a href="#代码-标记一小段行内代码" class="headerlink" title="代码(标记一小段行内代码)"></a>代码(标记一小段行内代码)</h1><pre><code>Use the `printf()` function.
</code></pre><p>Use the <code>printf()</code> function.</p>
<h3 id="如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段"><a href="#如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段" class="headerlink" title="如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段"></a>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段</h3><pre><code>``There is a literal backtick (`) here.``
</code></pre><p><code>There is a literal backtick (`) here.</code></p>
<h3 id="代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号"><a href="#代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号" class="headerlink" title="代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号"></a>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号</h3><pre><code>A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
</code></pre><p>A single backtick in a code span: <code>` </code></p>
<p>A backtick-delimited string in a code span: <code>`foo` </code></p>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h3 id="行内式和参考式"><a href="#行内式和参考式" class="headerlink" title="行内式和参考式"></a>行内式和参考式</h3><h4 id="行内式-gt-Alt-text-path-to-img-jpg-quot-Optional-title-quot"><a href="#行内式-gt-Alt-text-path-to-img-jpg-quot-Optional-title-quot" class="headerlink" title="行内式-&gt;![Alt text](/path/to/img.jpg &quot;Optional title&quot;)"></a>行内式-&gt;<code>![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code></h4><pre><code>![image](/img/boy.png &quot;boy.png&quot;)
</code></pre><p><img src="/img/boy.png" alt="image" title="boy.png"></p>
<h4 id="参考式-gt-Alt-text-id-id-url-to-image-quot-Optional-title-attribute-quot"><a href="#参考式-gt-Alt-text-id-id-url-to-image-quot-Optional-title-attribute-quot" class="headerlink" title="参考式-&gt;![Alt text][id] [id]: url/to/image  &quot;Optional title attribute&quot;"></a>参考式-&gt;<code>![Alt text][id] [id]: url/to/image  &quot;Optional title attribute&quot;</code></h4><pre><code>![image][boy]
[boy]: /img/boy.png &quot;boy.png&quot;
</code></pre><p><img src="/img/boy.png" alt="image" title="boy.png"></p>
<p>Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h1 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h1><h3 id="处理网址和电子邮件信箱"><a href="#处理网址和电子邮件信箱" class="headerlink" title="处理网址和电子邮件信箱"></a>处理网址和电子邮件信箱</h3><h3 id="只要是用尖括号包起来，-Markdown-就会自动把它转成链接-网址的链接文字就和链接地址一样"><a href="#只要是用尖括号包起来，-Markdown-就会自动把它转成链接-网址的链接文字就和链接地址一样" class="headerlink" title="只要是用尖括号包起来， Markdown 就会自动把它转成链接(网址的链接文字就和链接地址一样)"></a>只要是用尖括号包起来， Markdown 就会自动把它转成链接(网址的链接文字就和链接地址一样)</h3><pre><code>&lt;http://www.baidu.com/&gt;

&lt;1245204973@qq.com&gt;
</code></pre><p><a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a></p>
<p><a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x31;&#x32;&#x34;&#53;&#50;&#48;&#52;&#57;&#x37;&#x33;&#x40;&#x71;&#113;&#46;&#99;&#111;&#x6d;">&#x31;&#x32;&#x34;&#53;&#50;&#48;&#52;&#57;&#x37;&#x33;&#x40;&#x71;&#113;&#46;&#99;&#111;&#x6d;</a></p>
<p>Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人</p>
<h1 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h1><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><pre><code>\   反斜线
`   反引号
*   星号
_   底线
{}  花括号
[]  方括号
()  括弧
#   井字号
+   加号
-   减号
.   英文句点
!   惊叹号
</code></pre><h2 id="第一次写博客的经验"><a href="#第一次写博客的经验" class="headerlink" title="第一次写博客的经验"></a>第一次写博客的经验</h2><h3 id="本人使用的是hexo博客框架"><a href="#本人使用的是hexo博客框架" class="headerlink" title="本人使用的是hexo博客框架"></a>本人使用的是hexo博客框架</h3><p>1.开始写文章时应该先用<code>hexo new [layout] &lt;title&gt;</code>命令来创建一篇新的文章(有时候就是因为没有执行这条命令而直接手动在<code>.../blog/source/_posts</code>目录下创建一个<code>.md</code>文件，就会在生成并部署时发生一些错误的报错–即本身没有错，它却给你报错了)</p>
<p>2.使用上述命令解决了创建问题，接下来是部署的问题，部署的时候有可能不能一次性成功，哪怕上一次还成功部署了(或许是上一次我运气好吧)；后来看控制台报错得知好像是邮箱<code>private</code>的问题，看到这里我好像记起来在上一次成功部署之后有点得意，便在<code>github</code>上逛了一下，就是那时我把邮箱改成了<code>private</code>，见截图：<img src="/img/email_private.png" alt="email_private" title="email_private.png"><br>接下来我改回来，问题果然就解决了    –记得在部署前一定要先生成静态文件(<code>hexo generate</code>)，之后再部署，不然服务器上的内容不会发生变化(原因是你本次部署上去的public内容和上次是一样的)，可以使用<code>hexo generate --deploy</code>命令实现生成完毕后自动部署，而且部署前应该先在本地测试正常后再部署到服务器上，避免重复部署不需要的内容</p>
<p>3.还有一点就是在文章中添加图片，方法是在<code>.../blog/source</code>目录下创建一个<code>img</code>文件(其他的也可以)，文章中这样写：<code>![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code>，这是例子：<code>![image](/img/boy.png &quot;boy.png&quot;)</code></p>
<p>4.当部署完成后登陆网站查看文章时，会发现发布内容的排版和本地编辑器的预览有出入，这时可能是缓存问题，就需要在生成部署前执行命令<code>hexo clean</code>清除缓存，再者还是不行的话，就继续更改<code>.md</code>源文件，比如说在一些列表和引用处使用换行将每项分隔开，这样应该就能得到解决了</p>
<p>还有，markdown里面的空格和换行好磨人，要养成使用空格和换行的好习惯<code>(っ•̀ω•́)っ✎⁾⁾</code>我爱学习</p>
<p>目前就记这么多吧，后面学习过程中再慢慢积累~~~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/09/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/09/test/" itemprop="url">test</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-09T15:36:27+08:00">
                2017-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>This is a test!</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/08/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="newlife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="newlife's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/08/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-08T11:06:32+08:00">
                2017-12-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="newlife" />
            
              <p class="site-author-name" itemprop="name">newlife</p>
              <p class="site-description motion-element" itemprop="description">newlife means newborn</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/newlife201702" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:1245204973@qq.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">newlife</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
